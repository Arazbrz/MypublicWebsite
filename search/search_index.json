{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome! \u00b6 This is the Personal Website of Araz Karimi, Electrical and Computer Engineering Graduate who am I? \u00b6 I got my bachelor's from University of Tabriz with as a top student and got accepted to University of tehran to continue my education an graduate level. After University of Tehran, I attanded Georgia Tech as a PhD student but expanded my filed towards computer engineering. Full CV: CV What Can I do \u00b6 During the course of my education, I got experience in: Power System Simulation and Design Inverter Control Design Protection System simulation and Design Overhead transmission line Design Power Quality Improvement Strategies Power System Optimal Control Strategy Development Street and Building Lighting Design Troubleshooting and testing power aparatus and boards and I am familiar with using Software such as: - DigSilent Power Factory - Matlab Simulink - CYME - PLECS - GAMS - Comsol I am able to deeply personalize the functionality of these software using my programming skills. Examples . I can code in: - C++ - Python - Matlab I leverage highTech Machine learning, Optimal Control and Optimization techniques into real world practical power industry problems to deliver smart solutions.","title":"Home"},{"location":"#welcome","text":"This is the Personal Website of Araz Karimi, Electrical and Computer Engineering Graduate","title":"Welcome!"},{"location":"#who-am-i","text":"I got my bachelor's from University of Tabriz with as a top student and got accepted to University of tehran to continue my education an graduate level. After University of Tehran, I attanded Georgia Tech as a PhD student but expanded my filed towards computer engineering. Full CV: CV","title":"who am I?"},{"location":"#what-can-i-do","text":"During the course of my education, I got experience in: Power System Simulation and Design Inverter Control Design Protection System simulation and Design Overhead transmission line Design Power Quality Improvement Strategies Power System Optimal Control Strategy Development Street and Building Lighting Design Troubleshooting and testing power aparatus and boards and I am familiar with using Software such as: - DigSilent Power Factory - Matlab Simulink - CYME - PLECS - GAMS - Comsol I am able to deeply personalize the functionality of these software using my programming skills. Examples . I can code in: - C++ - Python - Matlab I leverage highTech Machine learning, Optimal Control and Optimization techniques into real world practical power industry problems to deliver smart solutions.","title":"What Can I do"},{"location":"CN/Heat_and_power/Heat_and_power/","text":"Introduction \u00b6 In this lab, you will examine the power requirements of a system and the associated heat disipation requirements. You will examine a modern chipset and estimate the heat disipation requirements for the chip. Finally you are going specify a heat sink for the chiip based on the heat requirements. The files you need for this assignment are found in the zip file: assignment.zip Procesor Power \u00b6 Examine the data sheet for the Intel 12 th Generation CPU and determine the following values for the P-Processor Line: 1. The thermal trip temperature in degrees C. This is the temerature at which the processor will shut down to avoid damage. 2. The maximum power consumption. There are several power measurements, but when desinging for thermal you should take the worst case into consideration. Find the maximum power consumption as assured by the data sheet. 3. The size of the physical chip. To size a heat sink the surface area of the heat sink must be in contact with the chip for optional heat transfer. Size the Heat Sink \u00b6 The heat sink can be sized based on the power dissipated. An approximation can be used to get a general idea of the size reqiured using the web site below: Heat Sink Size Calculator The background on this equation can be found here: Heat Sink Size Background Assume: Room temperature is 25C. After you find the approximate diminsions of your heat sink, search the internet and find a heat sink that will work. Please note your heat sink must have a data sheet. An example data sheet can be found in the zip file assignment.zip . Specifically we are looking for a heat sink with specific Thermal Resistances at different fan speeds. Thermal Circuit \u00b6 Using the actual heat sink create a Thermal Circuit to make sure the system will operate. Assume: That \u0398jc is 4.33 C/W. What is the maximum power for heat disipation given your selected heat sink and air flow rate?","title":"Power and Heat Lab"},{"location":"CN/Heat_and_power/Heat_and_power/#introduction","text":"In this lab, you will examine the power requirements of a system and the associated heat disipation requirements. You will examine a modern chipset and estimate the heat disipation requirements for the chip. Finally you are going specify a heat sink for the chiip based on the heat requirements. The files you need for this assignment are found in the zip file: assignment.zip","title":"Introduction"},{"location":"CN/Heat_and_power/Heat_and_power/#procesor-power","text":"Examine the data sheet for the Intel 12 th Generation CPU and determine the following values for the P-Processor Line: 1. The thermal trip temperature in degrees C. This is the temerature at which the processor will shut down to avoid damage. 2. The maximum power consumption. There are several power measurements, but when desinging for thermal you should take the worst case into consideration. Find the maximum power consumption as assured by the data sheet. 3. The size of the physical chip. To size a heat sink the surface area of the heat sink must be in contact with the chip for optional heat transfer.","title":"Procesor Power"},{"location":"CN/Heat_and_power/Heat_and_power/#size-the-heat-sink","text":"The heat sink can be sized based on the power dissipated. An approximation can be used to get a general idea of the size reqiured using the web site below: Heat Sink Size Calculator The background on this equation can be found here: Heat Sink Size Background Assume: Room temperature is 25C. After you find the approximate diminsions of your heat sink, search the internet and find a heat sink that will work. Please note your heat sink must have a data sheet. An example data sheet can be found in the zip file assignment.zip . Specifically we are looking for a heat sink with specific Thermal Resistances at different fan speeds.","title":"Size the Heat Sink"},{"location":"CN/Heat_and_power/Heat_and_power/#thermal-circuit","text":"Using the actual heat sink create a Thermal Circuit to make sure the system will operate. Assume: That \u0398jc is 4.33 C/W. What is the maximum power for heat disipation given your selected heat sink and air flow rate?","title":"Thermal Circuit"},{"location":"CN/cache/cache/","text":"Lab Description \u00b6 The lab files can be downloaded here : assignment.zip In this lab, you will write a cache simulator that you will use to evaluate and compare the cache hit rates for several cache architectures. This assignment is designed to be completed in C . Coding this simulator in C will best prepare you for future classes that use this class as a prerequisite. All starter code we provide you is written in C. You may use C++ as well -- you are responsible for any changes necessary (ex: changing the file extension). Given a cache memory organization, your simulator should read a file containing a memory trace (a sequence of memory addresses) and determine which of the memory references will cause cache hits (and which will cause misses). The program should keep track of the number of hits and misses generated by each cache over the entire trace. For every memory access you will need to update your cache data structures and update any cache statistics (more on this later). Trace File \u00b6 Three trace files are available in the Traces folder. Each line has three fields. The first field gives the type of the memory reference (2 for instruction fetch, 1 for a store's data memory write, and 0 for a load's data memory read). The second field on the line is the address. The third field gives the instruction value for a fetch and is always 0 for loads and stores (Not used in this lab). For e.g., the gcc trace file has 1,000,000 memory references (one per line) and was collected from the gcc while it was running on a MIPS processor. The Simulator \u00b6 Your task is to simulate an architecture with a writeback cache --a data cache (D-cache). The cache will be placed between the CPU and memory. The data cache will be used to cache data reads/writes. The cache will use an LRU replacement policy. When initializing the cache, you will be given a block size, a cache size and an associativity (maximum of 32) -- these will always be powers of 2. For every access your cache makes, you will be provided an address and an access type (mem read, mem write, or instruction read). For every cache access, you will need to update the data structures you are using and the cache statistics to reflect the occurrence of that cache access. The statistics you will need to keep track of are the total accesses, total misses, D-cache accesses, D-cache misses and writebacks. Simulator Basics \u00b6 You only need to implement the cache directory and not the data section. For each cache block you need to keep track of the tag, valid bit, and dirty bit (was the cache line modified?). For each set you need to keep track of the LRU status of the blocks in the set. Dynamically allocate and create the directory data structure. Read and process each address from the trace file -- read a memory reference, extract the index and tag, determine whether it is a hit or a miss, update the directory structure and any other data structures you add (for example counters keeping track of the number of hits or number of references). Do not forget to update the LRU status. You are simulating only one cache configuration at a time. It is imperative that you implement the simulator on your own . Assignment submissions will be checked with code similarity analysis tools including against publicly and previously available code bases. [Understanding the Given Code]{.underline} To help you get started on the lab, some starter code has been provided for you. The code provided to you is as follows: cachesim.h: contains some declarations that define data types, structs and functions for the simulator. We have provided some structs for a cache block and a cache set, but feel free to update anything that is not marked \"Do not modify\". cachesim.c: This file contains your main simulator code. This file already contains code to fetch the cache configuration, read the trace file, and run the full cache simulation. Your main job is to complete the cachesim_init and cachesim_access functions. All items are commented, so please check the code for more details on what/where changes are necessary. Please take note of some parts of the code we ask you not to change, as these parts are important for your simulator's outputs to stay standardized. lrustack.h: This file contains a potential interface for your LRU stack, with all functions thoroughly documented. Note that you can also ignore our starter code and write the LRU stack from scratch if you so desire. lrustack.c: This file contains a potential interface for your LRU stack, with all functions thoroughly documented. Note that you can also ignore our starter code and write the LRU stack from scratch if you so desire. lrustacktest.c: This file contains some basic tests for the LRU stack (if you implemented it using the interface we set up). You can add tests if you want to test your LRU stack more thoroughly. You can rewrite the tests completely if you changed the interface. You will not be graded on your LRU Stack tests in this file -- this is simply provided to help ensure your LRU stack implementation works correctly before integrating it into the full simulator. **All locations where you will need to make changes are marked with \"TODO\" comments -- feel free to remove these comments when done implementing your cache simulator. ** Compiling, Running and Debugging \u00b6 Compiling LRU stack test: gcc lrustack.h lrustack.c lrustacktest.c -o lrustacktest Running LRU stack test: ./lrustacktest Compiling the cache simulator: gcc lrustack.h lrustack.c cachesim.h cachesim.c -o cachesim Running the cache simulator: ./cachesim <trace> <block_size>, <cache_size>, <associativity> Expected outputs: The Tests folder lists the sample outputs for the three traces provided. However, your code will also be evaluated against additional traces. Make sure all code compiles and runs without issue before making any changes. A good debugging tool is GDB. You can find a good intro to using GDB at https://www.geeksforgeeks.org/gdb-step-by-step-introduction/ Assignment (100 pts) \u00b6 Determine hit rates, miss rates, and writeback traffic for various configuration of a 64 Kbyte unified set associative cache (instruction and data), assuming a cold cache for each trace - the cache is initially empty and all lines are in the invalid state. The cache configuration is a combination of the line size and associativity. Configuration parameters include: cache block size (32 byte, 64 byte, 128 byte, 256 byte, and 512 byte) and associativity (2, 4, 8) . Submission Requirements \u00b6 Your code If you coded in C++ : update the create_submission.sh to zip the files you used -- by default, they try to zip the .c and .h files. You can use create_submission.sh to create ece3058_cachelab_submission.tar.gz . It is your responsibility to make sure all files necessary to run the simulator are included in the submission. Please make sure your code is well documented. Do not include the trace file or points will be deducted. Grading Guidelines \u00b6 IMPORTANT NOTES: If your code does not compile your assignment cannot be graded. If your code crashes/seg. faults or produces unreadable output it cannot be graded. Your code will be graded according to a randomly selected combination of parameters (cache size, line size, associativities and trace files). Its accuracy will be compared against our solution simulator. GRADING RUBRIC: \u00b6 Program compiles and executes 25 points Results are largely correct, but answers may 60 points be slightly incorrect Results are precisely correct 70 points Code is documented 5 points TOTAL 100 points Note: You must achieve a minimum average of 50% in the lab assignments to pass the course. Extra Credit (50 points) \u00b6 This portion will only be graded once you have completed the above parts of the assignment.** Extend your simulator to Have a separate 16 Kbyte direct mapped I-cache and 16 Kbyte direct mapped D-Cache each with 64 byte lines. Include a 256 Kbyte, K-way set associative unified L2 cache with a line size of 64 bytes and a write-back update policy. The L2 cache should inclusive (details below), meaning all the data in the L1 cache is also in the L2 cache (keep in mind what this means for the associativity/number of sets of the L2 cache with respect to the L1 cache). Consider the configuration of the L2 with 64 byte lines and associativity 8 a. Compute the local miss rates and the global miss rates for each trace for instructions and data. b. What value of associativity minimizes the global miss rate for data. c. What is the total volume of traffic between the L1 D-cache and the L2 for each trace. Write your own test cases for your L2 Cache, and be prepared to demo how you test case fully showcases the benefits of an additional L2 Cache. Please follow the instruction on Canvas to submit or demonstrate the extra credit part. Inclusive L2 \u00b6 In the case of multilevel caches (assume two-level -L1 and L2), if the contents of L1 are always contained in L2, caching is said to be inclusive. Read or Write Misses If the block is not found in either L1 or L2, then it is fetched from the main memory and placed in both L1 and L2. Read Hits Suppose there is a read request for block (i.e., line) X. If the block is found in L1 cache (hit), then the data is read from L1 cache and returned to the processor. If the block is not found in the L1 cache (L1 miss), but present in the L2 cache (L2 hit), then the cache block is fetched from the L2 cache and placed in L1. Write Hits When you write to a line in L1 (now dirty), you don't need to worry about updating L2 till this line is evicted from L1 due to replacement. In this case, you will update L2 (note - this won't be a writeback since you aren't updating memory). If you miss in L1 but find the block in L2, you will bring it into L1 and update it at L1. Evictions If a block is evicted from L1, there is no involvement of L2. If a block is evicted from L2, the L2 cache sends a back invalidation to the L1 cache, so that inclusion is not violated. When an eviction in L2 causes a dirty L1 line to be invalidated, in this case, you will update the memory and increment writebacks. Traffic The traffic between L1 and L2 constitutes (i) data is brought from L2 into L1 on a L1 miss but L2 hit, (ii) invalidations sent to L1 when a line is evicted from L2, (iii) updates to L2 due to a dirty line being evicted from L1. Breaking it Down Into Bite-Sized Pieces \u00b6 Read the instructions again. Brainstorm and Design: Spend time thinking through the design, i.e., the directory data structure and all the counters you will need to record the requested information. Specify the data structures you need for the tag directory and LRU stacks. It is highly recommended that you draw the data structures and mentally walk through the processing of a reference. Do this analysis before you ever write a line of code. It will save you a lot of time and stress. Most people spend time debugging and hacking away at a piece of code, which was written before they thought through the details. Create your own traces of addresses rather than starting with the original traces. Create sequences for which you know the behavior. For example, create a sequence of 100 identical addresses -- you will have one miss and 99 hits. Another test case is a repeating sequence of addresses that will conflict in the cache -- for example two addresses with the same index but different tag and a direct mapped cache. You know the answer to these cases and can easily check the results for correctness. Parse Address: Write a test program to just be able to read the trace and parse the address into tag, and set. Make sure you can read the trace correctly and print the set index and tag. Once you are sure of this, then you can focus on the cache data structures. LRU Replacement: You will need some form of LRU replacement in your simulator. Coding this is often one of the harder parts of this lab. In the starter code, we have isolated the LRU code into lrustack.h/lrustack.c, so you can test your LRU implementation independent of the cache. The file lrustack.h/lrustack.c defines a potential interface to interact with an LRU stack. If you implement LRU according to the provided comments, you will be able to sanity check it against some basic tests we provide in lrustacktest.c. Note, these tests may not be exhaustive, but they are a good sanity check to ensure your LRU implementation is correct. If you want more exhaustive tests, feel free to add them! If you want to implement an LRU stack your own way, feel free to do that as well! We still recommend testing the LRU stack separately before proceeding on with the rest of the simulator. Cache simulator initialization: Write the function to initialize your cache simulator. Cache access: Write the function to run a cache access. Partial Verification: Run the simulator with your traces and verify it behaves as expected. Full Verification: Now run the full traces. We will provide you with statistics the TA implementation gets for certain configurations so you can verify your cache simulator is working. Experiments and Report: See above instructions. Thinking through the design of your simulator up front should minimize the time it takes you to complete the assignment. As mentioned earlier, debugging time is typically the biggest component of projects. Some clear up-front thinking will save you much of that time. The actual code size is not very large for a C program. START EARLY and utilize recitation/office hours!","title":"Cache Lab"},{"location":"CN/cache/cache/#lab-description","text":"The lab files can be downloaded here : assignment.zip In this lab, you will write a cache simulator that you will use to evaluate and compare the cache hit rates for several cache architectures. This assignment is designed to be completed in C . Coding this simulator in C will best prepare you for future classes that use this class as a prerequisite. All starter code we provide you is written in C. You may use C++ as well -- you are responsible for any changes necessary (ex: changing the file extension). Given a cache memory organization, your simulator should read a file containing a memory trace (a sequence of memory addresses) and determine which of the memory references will cause cache hits (and which will cause misses). The program should keep track of the number of hits and misses generated by each cache over the entire trace. For every memory access you will need to update your cache data structures and update any cache statistics (more on this later).","title":"Lab Description"},{"location":"CN/cache/cache/#trace-file","text":"Three trace files are available in the Traces folder. Each line has three fields. The first field gives the type of the memory reference (2 for instruction fetch, 1 for a store's data memory write, and 0 for a load's data memory read). The second field on the line is the address. The third field gives the instruction value for a fetch and is always 0 for loads and stores (Not used in this lab). For e.g., the gcc trace file has 1,000,000 memory references (one per line) and was collected from the gcc while it was running on a MIPS processor.","title":"Trace File"},{"location":"CN/cache/cache/#the-simulator","text":"Your task is to simulate an architecture with a writeback cache --a data cache (D-cache). The cache will be placed between the CPU and memory. The data cache will be used to cache data reads/writes. The cache will use an LRU replacement policy. When initializing the cache, you will be given a block size, a cache size and an associativity (maximum of 32) -- these will always be powers of 2. For every access your cache makes, you will be provided an address and an access type (mem read, mem write, or instruction read). For every cache access, you will need to update the data structures you are using and the cache statistics to reflect the occurrence of that cache access. The statistics you will need to keep track of are the total accesses, total misses, D-cache accesses, D-cache misses and writebacks.","title":"The Simulator"},{"location":"CN/cache/cache/#simulator-basics","text":"You only need to implement the cache directory and not the data section. For each cache block you need to keep track of the tag, valid bit, and dirty bit (was the cache line modified?). For each set you need to keep track of the LRU status of the blocks in the set. Dynamically allocate and create the directory data structure. Read and process each address from the trace file -- read a memory reference, extract the index and tag, determine whether it is a hit or a miss, update the directory structure and any other data structures you add (for example counters keeping track of the number of hits or number of references). Do not forget to update the LRU status. You are simulating only one cache configuration at a time. It is imperative that you implement the simulator on your own . Assignment submissions will be checked with code similarity analysis tools including against publicly and previously available code bases. [Understanding the Given Code]{.underline} To help you get started on the lab, some starter code has been provided for you. The code provided to you is as follows: cachesim.h: contains some declarations that define data types, structs and functions for the simulator. We have provided some structs for a cache block and a cache set, but feel free to update anything that is not marked \"Do not modify\". cachesim.c: This file contains your main simulator code. This file already contains code to fetch the cache configuration, read the trace file, and run the full cache simulation. Your main job is to complete the cachesim_init and cachesim_access functions. All items are commented, so please check the code for more details on what/where changes are necessary. Please take note of some parts of the code we ask you not to change, as these parts are important for your simulator's outputs to stay standardized. lrustack.h: This file contains a potential interface for your LRU stack, with all functions thoroughly documented. Note that you can also ignore our starter code and write the LRU stack from scratch if you so desire. lrustack.c: This file contains a potential interface for your LRU stack, with all functions thoroughly documented. Note that you can also ignore our starter code and write the LRU stack from scratch if you so desire. lrustacktest.c: This file contains some basic tests for the LRU stack (if you implemented it using the interface we set up). You can add tests if you want to test your LRU stack more thoroughly. You can rewrite the tests completely if you changed the interface. You will not be graded on your LRU Stack tests in this file -- this is simply provided to help ensure your LRU stack implementation works correctly before integrating it into the full simulator. **All locations where you will need to make changes are marked with \"TODO\" comments -- feel free to remove these comments when done implementing your cache simulator. **","title":"Simulator Basics"},{"location":"CN/cache/cache/#compiling-running-and-debugging","text":"Compiling LRU stack test: gcc lrustack.h lrustack.c lrustacktest.c -o lrustacktest Running LRU stack test: ./lrustacktest Compiling the cache simulator: gcc lrustack.h lrustack.c cachesim.h cachesim.c -o cachesim Running the cache simulator: ./cachesim <trace> <block_size>, <cache_size>, <associativity> Expected outputs: The Tests folder lists the sample outputs for the three traces provided. However, your code will also be evaluated against additional traces. Make sure all code compiles and runs without issue before making any changes. A good debugging tool is GDB. You can find a good intro to using GDB at https://www.geeksforgeeks.org/gdb-step-by-step-introduction/","title":"Compiling, Running and Debugging"},{"location":"CN/cache/cache/#assignment-100-pts","text":"Determine hit rates, miss rates, and writeback traffic for various configuration of a 64 Kbyte unified set associative cache (instruction and data), assuming a cold cache for each trace - the cache is initially empty and all lines are in the invalid state. The cache configuration is a combination of the line size and associativity. Configuration parameters include: cache block size (32 byte, 64 byte, 128 byte, 256 byte, and 512 byte) and associativity (2, 4, 8) .","title":"Assignment (100 pts)"},{"location":"CN/cache/cache/#submission-requirements","text":"Your code If you coded in C++ : update the create_submission.sh to zip the files you used -- by default, they try to zip the .c and .h files. You can use create_submission.sh to create ece3058_cachelab_submission.tar.gz . It is your responsibility to make sure all files necessary to run the simulator are included in the submission. Please make sure your code is well documented. Do not include the trace file or points will be deducted.","title":"Submission Requirements"},{"location":"CN/cache/cache/#grading-guidelines","text":"IMPORTANT NOTES: If your code does not compile your assignment cannot be graded. If your code crashes/seg. faults or produces unreadable output it cannot be graded. Your code will be graded according to a randomly selected combination of parameters (cache size, line size, associativities and trace files). Its accuracy will be compared against our solution simulator.","title":"Grading Guidelines"},{"location":"CN/cache/cache/#grading-rubric","text":"Program compiles and executes 25 points Results are largely correct, but answers may 60 points be slightly incorrect Results are precisely correct 70 points Code is documented 5 points TOTAL 100 points Note: You must achieve a minimum average of 50% in the lab assignments to pass the course.","title":"GRADING RUBRIC:"},{"location":"CN/cache/cache/#extra-credit-50-points","text":"This portion will only be graded once you have completed the above parts of the assignment.** Extend your simulator to Have a separate 16 Kbyte direct mapped I-cache and 16 Kbyte direct mapped D-Cache each with 64 byte lines. Include a 256 Kbyte, K-way set associative unified L2 cache with a line size of 64 bytes and a write-back update policy. The L2 cache should inclusive (details below), meaning all the data in the L1 cache is also in the L2 cache (keep in mind what this means for the associativity/number of sets of the L2 cache with respect to the L1 cache). Consider the configuration of the L2 with 64 byte lines and associativity 8 a. Compute the local miss rates and the global miss rates for each trace for instructions and data. b. What value of associativity minimizes the global miss rate for data. c. What is the total volume of traffic between the L1 D-cache and the L2 for each trace. Write your own test cases for your L2 Cache, and be prepared to demo how you test case fully showcases the benefits of an additional L2 Cache. Please follow the instruction on Canvas to submit or demonstrate the extra credit part.","title":"Extra Credit (50 points)"},{"location":"CN/cache/cache/#inclusive-l2","text":"In the case of multilevel caches (assume two-level -L1 and L2), if the contents of L1 are always contained in L2, caching is said to be inclusive. Read or Write Misses If the block is not found in either L1 or L2, then it is fetched from the main memory and placed in both L1 and L2. Read Hits Suppose there is a read request for block (i.e., line) X. If the block is found in L1 cache (hit), then the data is read from L1 cache and returned to the processor. If the block is not found in the L1 cache (L1 miss), but present in the L2 cache (L2 hit), then the cache block is fetched from the L2 cache and placed in L1. Write Hits When you write to a line in L1 (now dirty), you don't need to worry about updating L2 till this line is evicted from L1 due to replacement. In this case, you will update L2 (note - this won't be a writeback since you aren't updating memory). If you miss in L1 but find the block in L2, you will bring it into L1 and update it at L1. Evictions If a block is evicted from L1, there is no involvement of L2. If a block is evicted from L2, the L2 cache sends a back invalidation to the L1 cache, so that inclusion is not violated. When an eviction in L2 causes a dirty L1 line to be invalidated, in this case, you will update the memory and increment writebacks. Traffic The traffic between L1 and L2 constitutes (i) data is brought from L2 into L1 on a L1 miss but L2 hit, (ii) invalidations sent to L1 when a line is evicted from L2, (iii) updates to L2 due to a dirty line being evicted from L1.","title":"Inclusive L2"},{"location":"CN/cache/cache/#breaking-it-down-into-bite-sized-pieces","text":"Read the instructions again. Brainstorm and Design: Spend time thinking through the design, i.e., the directory data structure and all the counters you will need to record the requested information. Specify the data structures you need for the tag directory and LRU stacks. It is highly recommended that you draw the data structures and mentally walk through the processing of a reference. Do this analysis before you ever write a line of code. It will save you a lot of time and stress. Most people spend time debugging and hacking away at a piece of code, which was written before they thought through the details. Create your own traces of addresses rather than starting with the original traces. Create sequences for which you know the behavior. For example, create a sequence of 100 identical addresses -- you will have one miss and 99 hits. Another test case is a repeating sequence of addresses that will conflict in the cache -- for example two addresses with the same index but different tag and a direct mapped cache. You know the answer to these cases and can easily check the results for correctness. Parse Address: Write a test program to just be able to read the trace and parse the address into tag, and set. Make sure you can read the trace correctly and print the set index and tag. Once you are sure of this, then you can focus on the cache data structures. LRU Replacement: You will need some form of LRU replacement in your simulator. Coding this is often one of the harder parts of this lab. In the starter code, we have isolated the LRU code into lrustack.h/lrustack.c, so you can test your LRU implementation independent of the cache. The file lrustack.h/lrustack.c defines a potential interface to interact with an LRU stack. If you implement LRU according to the provided comments, you will be able to sanity check it against some basic tests we provide in lrustacktest.c. Note, these tests may not be exhaustive, but they are a good sanity check to ensure your LRU implementation is correct. If you want more exhaustive tests, feel free to add them! If you want to implement an LRU stack your own way, feel free to do that as well! We still recommend testing the LRU stack separately before proceeding on with the rest of the simulator. Cache simulator initialization: Write the function to initialize your cache simulator. Cache access: Write the function to run a cache access. Partial Verification: Run the simulator with your traces and verify it behaves as expected. Full Verification: Now run the full traces. We will provide you with statistics the TA implementation gets for certain configurations so you can verify your cache simulator is working. Experiments and Report: See above instructions. Thinking through the design of your simulator up front should minimize the time it takes you to complete the assignment. As mentioned earlier, debugging time is typically the biggest component of projects. Some clear up-front thinking will save you much of that time. The actual code size is not very large for a C program. START EARLY and utilize recitation/office hours!","title":"Breaking it Down Into Bite-Sized Pieces"},{"location":"CN/intro/intro/","text":"This is a practice lab meant to get you started with the basic concepts needed for future labs. Instead of copying and pasting text included in this lab, you can download all the files below here . Background Information \u00b6 What is RTL or HDL? \u00b6 A Hardware Description Language(HDL) is purely that. It merely describes hardware both structurally and functionally in the form of code. There are a couple types of HDLs, digital and mixed(digital+analog). This class deals with digital HDLs such as VHDL which you should have seen in ECE2031 (Digital Design Laboratory). The most common HDLs include VHDL and Verilog. In the labs, we will use mostly Verilog. This can be a good reference for verilog: https://www.asic-world.com/verilog/veritut.html . If you want additional help with verilog, here is another primer that is helpful Verilog primer The digital subset of HDL is usually referred to as Register Transfer Logic(RTL). RTLs aren't very useful by themselves. Typically, they might be passed to a synthesizer which reduces the RTL into a gate list that describes all the connections between various gates. A gate list is more commonly known as a netlist. Synthesizers \u00b6 There are different kinds of synthesizers. Some synthesizer frameworks target FPGAs while others target physical fabrication or VLSI. In VLSI, RTL is just the first step in a long laborious sequence of tasks that usually results in a finished physical chip. All synthesizers typically support both VHDL and Verilog. Writing Verilog or VHDL is very primitive however, so it is not uncommon to use a higher level language to generate Verilog (I heard somewhere that Perl is sometimes used in industry to generate Verilog). Higher Level Languages and Simulation \u00b6 Using a higher level language can make complex tasks such as generating an out-of-order, multi-cache, multi-issue, pipelined processor easier. TestBench or TestBeds \u00b6 After you write your HDL that creates a circuit, you will need something else to test the functionality. Testbenches are HDL code written to test another HDL module (device under test or DUT). Testbenchess can output data to be analyzed as well as automatically test if the values are correctly generated. Questions \u00b6 Q1 \u00b6 What is the first thing that happens when you turn on your processor? Please refer to page 25, section 5.2.4 of the MIPS32 Manual Volume III 1 . Q2 \u00b6 Computer programs can have many different sub-routines spread amongst different files. RTLs like verilog are no different. But instead of sub-routines, textual representations of physical hardware can be separated into distinct components called modules. Below we have a synchronous adder module. module sync_adder(Q, a, b, clk, reset); input wire clk, reset; input wire [7:0] a; input wire [7:0] b; output reg [7:0] Q; reg [7:0] sum; wire [7:0] D; always @(*) sum = a+b; assign D = sum; always @(posedge clk) if (reset == 1) Q <= 0; else Q <= D; endmodule Let's break this up \u00b6 module sync_adder(Q, a, b, clk, reset); input wire clk, reset; input wire [7:0] a; input wire [7:0] b; output reg [7:0] Q; These are the definitions of the input and output of the whole module. reg [7:0] sum; wire [7:0] D; Next are internal signals inside of the module. The sum can be implemented as a wire, but for demonstration purposes explained later, it is a register. always @(*) sum = a+b; This next bit of verilog represent the circled component. The sum is constantly being generated depending on the values of a and b. assign D = sum; This next line connects the adder sum output to the D input of the flip flop. assign change the value of the left hand side as soon as the the right had side changes. always @(posedge clk) if (reset == 1) Q <= 0; else Q <= D; This represents the internal flip flop. The value is assigned on the positive edge of the clock. Q2.1 \u00b6 What is the difference between wire and reg ? Q2.2 \u00b6 How do wire and reg compare to System Verilog's logic ? Q2.3 \u00b6 What do you think happens when we assert reset ? Q3 \u00b6 Now lets simulate the Verilog adder from above. Go to https://fpgasoftware.intel.com/?product=modelsim_ae#tabs-2 and make an account. Then make sure you select the \"lite\" edition and release \"20.1.1\". Download \"ModelSim-Intel FPGA Edition (includes Starter Edition)\" Opening verilog in ModelSim \u00b6 Download the lab0_files.zip . Unzip it and then place it in a directory. Navigate to the directory using ModelSim's command line. First, use the command cd c:/ to get to your main C: drive. Compiling verilog \u00b6 You can run do init.do which will create a design library. Then running do compile.do will compile the sync adder and the test bench. You will see a \"work\" folder. Open it and right click on sync_adder and click simulate. Right clicking on each w Run add wave -position insertpoint sim:/sync_adder_tb/* The waves will be added to the simulator. Running the command run -a will run all and you will see waveforms pop up (you may have to close a text editor window). It will look like this (Hint: clicking the Zoom Full or F will fit the signals in your window. Also you can right click on the waves and change the Radix. The a, b, and sum signals are changed to decimal in the image) sync_adder_tb.v \u00b6 Lets look at what the test bench does. This section breaks up the sync_adder_tb.v file. module sync_adder_tb; //signals needed to test functionality of sync adder reg clk, reset; reg [7:0] a; reg [7:0] b; wire [7:0] Q; //creating a sync adder and connecting signals sync_adder DUT( .clk(clk), .reset(reset), .a(a), .b(b), .Q(Q) ); This first part creates a test bench module. Included is hardware that will interact with the sync_adder DUT (Device Under Test). Then the hardware in the module is connected to the DUT. initial // initial block runs only once begin clk = 0; //Simple test a = 5; b = 7; reset = 0; #5 //self-checking a = 1; b = 6; reset = 0; #5 if (Q != 7) $display(\"1+6 failed\"); //self-checking a = 10; b = 15; reset = 0; #5 if (Q != 0) $display(\"10+15 is not 0!\"); The next part assert values to test the DUT. You can see the values for a, b, and reset are being set. The first test is a simple test where the result has to be verified manually. The next two checks show a method to self-check the result. The text in $display() will come onto the command line if the statement is true. You should see one of these statements in your command line after simulating. This section runs once and from begin to end consecutively. always #1 clk = ~clk; The last always block runs all the time and changes the clock value. Q3.1 modify the files \u00b6 Now modify the testbench above to do 4+5=9 with self checking. Also write verilog to test the reset functionality of the module. Recompile your verilog and fix any errors that pop up. Rerun the simulation. Include a screenshot of the new waveform with your lab. notes \u00b6 Congratulations!! You just wrote your first testbench. A testbench allows you to test your RTL before you deploy it to a chip or FGPA, and before you mix it with other RTL. https://www.cs.cornell.edu/courses/cs3410/2008fa/MIPS_Vol3.pdf \u21a9","title":"Gentle Intro"},{"location":"CN/intro/intro/#background-information","text":"","title":"Background Information"},{"location":"CN/intro/intro/#what-is-rtl-or-hdl","text":"A Hardware Description Language(HDL) is purely that. It merely describes hardware both structurally and functionally in the form of code. There are a couple types of HDLs, digital and mixed(digital+analog). This class deals with digital HDLs such as VHDL which you should have seen in ECE2031 (Digital Design Laboratory). The most common HDLs include VHDL and Verilog. In the labs, we will use mostly Verilog. This can be a good reference for verilog: https://www.asic-world.com/verilog/veritut.html . If you want additional help with verilog, here is another primer that is helpful Verilog primer The digital subset of HDL is usually referred to as Register Transfer Logic(RTL). RTLs aren't very useful by themselves. Typically, they might be passed to a synthesizer which reduces the RTL into a gate list that describes all the connections between various gates. A gate list is more commonly known as a netlist.","title":"What is RTL or HDL?"},{"location":"CN/intro/intro/#synthesizers","text":"There are different kinds of synthesizers. Some synthesizer frameworks target FPGAs while others target physical fabrication or VLSI. In VLSI, RTL is just the first step in a long laborious sequence of tasks that usually results in a finished physical chip. All synthesizers typically support both VHDL and Verilog. Writing Verilog or VHDL is very primitive however, so it is not uncommon to use a higher level language to generate Verilog (I heard somewhere that Perl is sometimes used in industry to generate Verilog).","title":"Synthesizers"},{"location":"CN/intro/intro/#higher-level-languages-and-simulation","text":"Using a higher level language can make complex tasks such as generating an out-of-order, multi-cache, multi-issue, pipelined processor easier.","title":"Higher Level Languages and Simulation"},{"location":"CN/intro/intro/#testbench-or-testbeds","text":"After you write your HDL that creates a circuit, you will need something else to test the functionality. Testbenches are HDL code written to test another HDL module (device under test or DUT). Testbenchess can output data to be analyzed as well as automatically test if the values are correctly generated.","title":"TestBench or TestBeds"},{"location":"CN/intro/intro/#questions","text":"","title":"Questions"},{"location":"CN/intro/intro/#q1","text":"What is the first thing that happens when you turn on your processor? Please refer to page 25, section 5.2.4 of the MIPS32 Manual Volume III 1 .","title":"Q1"},{"location":"CN/intro/intro/#q2","text":"Computer programs can have many different sub-routines spread amongst different files. RTLs like verilog are no different. But instead of sub-routines, textual representations of physical hardware can be separated into distinct components called modules. Below we have a synchronous adder module. module sync_adder(Q, a, b, clk, reset); input wire clk, reset; input wire [7:0] a; input wire [7:0] b; output reg [7:0] Q; reg [7:0] sum; wire [7:0] D; always @(*) sum = a+b; assign D = sum; always @(posedge clk) if (reset == 1) Q <= 0; else Q <= D; endmodule","title":"Q2"},{"location":"CN/intro/intro/#lets-break-this-up","text":"module sync_adder(Q, a, b, clk, reset); input wire clk, reset; input wire [7:0] a; input wire [7:0] b; output reg [7:0] Q; These are the definitions of the input and output of the whole module. reg [7:0] sum; wire [7:0] D; Next are internal signals inside of the module. The sum can be implemented as a wire, but for demonstration purposes explained later, it is a register. always @(*) sum = a+b; This next bit of verilog represent the circled component. The sum is constantly being generated depending on the values of a and b. assign D = sum; This next line connects the adder sum output to the D input of the flip flop. assign change the value of the left hand side as soon as the the right had side changes. always @(posedge clk) if (reset == 1) Q <= 0; else Q <= D; This represents the internal flip flop. The value is assigned on the positive edge of the clock.","title":"Let's break this up"},{"location":"CN/intro/intro/#q21","text":"What is the difference between wire and reg ?","title":"Q2.1"},{"location":"CN/intro/intro/#q22","text":"How do wire and reg compare to System Verilog's logic ?","title":"Q2.2"},{"location":"CN/intro/intro/#q23","text":"What do you think happens when we assert reset ?","title":"Q2.3"},{"location":"CN/intro/intro/#q3","text":"Now lets simulate the Verilog adder from above. Go to https://fpgasoftware.intel.com/?product=modelsim_ae#tabs-2 and make an account. Then make sure you select the \"lite\" edition and release \"20.1.1\". Download \"ModelSim-Intel FPGA Edition (includes Starter Edition)\"","title":"Q3"},{"location":"CN/intro/intro/#opening-verilog-in-modelsim","text":"Download the lab0_files.zip . Unzip it and then place it in a directory. Navigate to the directory using ModelSim's command line. First, use the command cd c:/ to get to your main C: drive.","title":"Opening verilog in ModelSim"},{"location":"CN/intro/intro/#compiling-verilog","text":"You can run do init.do which will create a design library. Then running do compile.do will compile the sync adder and the test bench. You will see a \"work\" folder. Open it and right click on sync_adder and click simulate. Right clicking on each w Run add wave -position insertpoint sim:/sync_adder_tb/* The waves will be added to the simulator. Running the command run -a will run all and you will see waveforms pop up (you may have to close a text editor window). It will look like this (Hint: clicking the Zoom Full or F will fit the signals in your window. Also you can right click on the waves and change the Radix. The a, b, and sum signals are changed to decimal in the image)","title":"Compiling verilog"},{"location":"CN/intro/intro/#sync_adder_tbv","text":"Lets look at what the test bench does. This section breaks up the sync_adder_tb.v file. module sync_adder_tb; //signals needed to test functionality of sync adder reg clk, reset; reg [7:0] a; reg [7:0] b; wire [7:0] Q; //creating a sync adder and connecting signals sync_adder DUT( .clk(clk), .reset(reset), .a(a), .b(b), .Q(Q) ); This first part creates a test bench module. Included is hardware that will interact with the sync_adder DUT (Device Under Test). Then the hardware in the module is connected to the DUT. initial // initial block runs only once begin clk = 0; //Simple test a = 5; b = 7; reset = 0; #5 //self-checking a = 1; b = 6; reset = 0; #5 if (Q != 7) $display(\"1+6 failed\"); //self-checking a = 10; b = 15; reset = 0; #5 if (Q != 0) $display(\"10+15 is not 0!\"); The next part assert values to test the DUT. You can see the values for a, b, and reset are being set. The first test is a simple test where the result has to be verified manually. The next two checks show a method to self-check the result. The text in $display() will come onto the command line if the statement is true. You should see one of these statements in your command line after simulating. This section runs once and from begin to end consecutively. always #1 clk = ~clk; The last always block runs all the time and changes the clock value.","title":"sync_adder_tb.v"},{"location":"CN/intro/intro/#q31-modify-the-files","text":"Now modify the testbench above to do 4+5=9 with self checking. Also write verilog to test the reset functionality of the module. Recompile your verilog and fix any errors that pop up. Rerun the simulation. Include a screenshot of the new waveform with your lab.","title":"Q3.1 modify the files"},{"location":"CN/intro/intro/#notes","text":"Congratulations!! You just wrote your first testbench. A testbench allows you to test your RTL before you deploy it to a chip or FGPA, and before you mix it with other RTL. https://www.cs.cornell.edu/courses/cs3410/2008fa/MIPS_Vol3.pdf \u21a9","title":"notes"},{"location":"CN/mips_emulation/mips_emulation/","text":"Go ahead and download the assignment. The details are provided inside the assignment.","title":"MIPS Emulation"},{"location":"CN/pipelined/pipelined/","text":"Required Tools for this lab \u00b6 Brew iverilog GTKwave or Scansion Lab Assignment 2 \u00b6 80 points Warning The pipeline implementation in this lab probably has a number of errors and is not perfect, but is presented nonetheless as is for teaching purposes. The processor supports the following instructions. The test cases that we run will ONLY include these instructions so you do not need to worry about your processor possibly encountering any other instructions. ADD | SUB | LW | SW | OR | AND | SLT | BEQ First click here to download the lab. Change into the rtl directory and run make to generate the sim.vcd , and then open it. In this lab, you will be implementing the following: Pretask: \u00b6 Similar to the previous lab, draw a block diagram and mark the data signals to drive the forward/stall using the signals in the modules. This will be helpful for your implementation. (Task 1: 20 points) . Add support for the load-to-use stall. For example, if a lw instruction produces data used by an immediately following instruction, one stall cycle should be included between the lw and the immediately following instruction. Currently the processor does not stall when the instruction following the load depends on it. The logic that needs to be repaired to add load-to-use stall is in the file STALL_CONT.sv . You can use op_stall signal. assign RS_EX_hazard = 0; assign RS_MEM_hazard = 0; assign RS_WB_hazard = 0; //Check to see if any of the stages have RS hazards logic RS_hazard; assign RS_hazard = RS_EX_hazard | RS_MEM_hazard | RS_WB_hazard; //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //Check if there is a hazard on RT //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //(rt(IRID)==destEX) && use_rt(IRID) && RegWriteEX or //(rt(IRID)==destMEM) && use_rt(IRID) && RegWriteMEM or //(rt(IRID)==destWB) && use_rt(IRID) && RegWriteWB logic RT_EX_hazard ; logic RT_MEM_hazard ; logic RT_WB_hazard ; assign RT_EX_hazard = 0; assign RT_MEM_hazard = 0; assign RT_WB_hazard = 0; For example, RT_EX_hazard is not always 0 , it is sometimes 1 . To give you a hint, RT_EX_hazard depends on ip_dest_EX , use_RT , and ip_RegWrite_EX . (Task 2: 40 points) . Implement data forwarding to the EX stage. There is a blank module called FWD_CONT.sv already created for you and instantiated within MIPS.sv. Feel free to modify the input/output ports if required in your implementation. Just how you checked for hazards in the STALL_CONT.sv file, you will check for hazards and forward the correct value from EX/MEM or MEM/WB stage to the execute unit. (Task 3: 20 points) . Implement flushing in the pipeline. Assume branches are predicted as not taken. Thus, the fetch stage will keep fetching instructions through PC+4 until the branch condition is resolved. Note that if the branch is taken, then the instructions which were speculatively fetched would have to be flushed. Flushing out will mean clearing out the relevant (before branch resolution) registers. It might help to start by filling out the table below. The number at the top of the table represent the cycle count. You can access the cycle count by viewing the cycle_cnt signal in MIPS_pipelined_tb in the waveform viewer. You'll notice that the first instruction in the table has already been filled in for you. Also, if you open IFETCH.sv , you'll notice that the instructions in the table below match those in the inst_ram 3 4 5 6 7 8 9 10 11 12 13 14 15 16 lw $2, 0 F D E M WB lw $3, 0x4 add $1, $2, $3 You can use a combination of lw, add, sub, beq to test out stalling, forwarding, and flushing. Testing and Debugging \u00b6 To help you debug as well as better understand the tasks of lab 2, we've provided the waveforms for some of the tests that are running in Gradescope. Their names below correspond to the test names you see in Gradescope. You are NOT REQUIRED to match these waveforms. They are only here to help you debug the test cases and show what the proper execution of the test cases should be in order to pass. The waveforms may even contain irrelevant wires and signals, but ultimately the most important considerations for our cases are the register and memory values as these are what ensure functional correctness and the proper implementation of the 5 stage in-order pipeline. You can decode the instruction DRAM values if you want to know the actual instructions that the test cases run. Please check canvas for the sample debugging waveforms Submission \u00b6 To clarify: 1. First implement stalling and verify that it is working properly. 2. Once stalling works implment forwarding. Verify forwarding is working by seeing only one stall in the case with a lw RAW. This is the case where the data is only avaliable after memory stage (you want to implement stalling first in order to verify that data is not being taken incorrectly in any case) 3. Implement flushing and verify functionality For submission, please submit your tarball to Gradescope under the Lab2 Pipelining Assignment. To generate the tarball If you're using the files in the regular assignment directory, simply just run make submit on your terminal where the Makefile is located (same as running make to generate your waveform). If you're using files in the __MACOSX directory, run the bash script create_submission.sh in the root directory of the assignment. After performing either of the two actions above, you'll end up with a file titled ece3058_lab2_submission.tar.gz that you will submit to Gradescope. Make sure you add comments for the changes. Do NOT submit 3 different RTL directories for the different tasks","title":"Pipelined Processor"},{"location":"CN/pipelined/pipelined/#required-tools-for-this-lab","text":"Brew iverilog GTKwave or Scansion","title":"Required Tools for this lab"},{"location":"CN/pipelined/pipelined/#lab-assignment-2","text":"80 points Warning The pipeline implementation in this lab probably has a number of errors and is not perfect, but is presented nonetheless as is for teaching purposes. The processor supports the following instructions. The test cases that we run will ONLY include these instructions so you do not need to worry about your processor possibly encountering any other instructions. ADD | SUB | LW | SW | OR | AND | SLT | BEQ First click here to download the lab. Change into the rtl directory and run make to generate the sim.vcd , and then open it. In this lab, you will be implementing the following:","title":"Lab Assignment 2"},{"location":"CN/pipelined/pipelined/#pretask","text":"Similar to the previous lab, draw a block diagram and mark the data signals to drive the forward/stall using the signals in the modules. This will be helpful for your implementation. (Task 1: 20 points) . Add support for the load-to-use stall. For example, if a lw instruction produces data used by an immediately following instruction, one stall cycle should be included between the lw and the immediately following instruction. Currently the processor does not stall when the instruction following the load depends on it. The logic that needs to be repaired to add load-to-use stall is in the file STALL_CONT.sv . You can use op_stall signal. assign RS_EX_hazard = 0; assign RS_MEM_hazard = 0; assign RS_WB_hazard = 0; //Check to see if any of the stages have RS hazards logic RS_hazard; assign RS_hazard = RS_EX_hazard | RS_MEM_hazard | RS_WB_hazard; //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //Check if there is a hazard on RT //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //(rt(IRID)==destEX) && use_rt(IRID) && RegWriteEX or //(rt(IRID)==destMEM) && use_rt(IRID) && RegWriteMEM or //(rt(IRID)==destWB) && use_rt(IRID) && RegWriteWB logic RT_EX_hazard ; logic RT_MEM_hazard ; logic RT_WB_hazard ; assign RT_EX_hazard = 0; assign RT_MEM_hazard = 0; assign RT_WB_hazard = 0; For example, RT_EX_hazard is not always 0 , it is sometimes 1 . To give you a hint, RT_EX_hazard depends on ip_dest_EX , use_RT , and ip_RegWrite_EX . (Task 2: 40 points) . Implement data forwarding to the EX stage. There is a blank module called FWD_CONT.sv already created for you and instantiated within MIPS.sv. Feel free to modify the input/output ports if required in your implementation. Just how you checked for hazards in the STALL_CONT.sv file, you will check for hazards and forward the correct value from EX/MEM or MEM/WB stage to the execute unit. (Task 3: 20 points) . Implement flushing in the pipeline. Assume branches are predicted as not taken. Thus, the fetch stage will keep fetching instructions through PC+4 until the branch condition is resolved. Note that if the branch is taken, then the instructions which were speculatively fetched would have to be flushed. Flushing out will mean clearing out the relevant (before branch resolution) registers. It might help to start by filling out the table below. The number at the top of the table represent the cycle count. You can access the cycle count by viewing the cycle_cnt signal in MIPS_pipelined_tb in the waveform viewer. You'll notice that the first instruction in the table has already been filled in for you. Also, if you open IFETCH.sv , you'll notice that the instructions in the table below match those in the inst_ram 3 4 5 6 7 8 9 10 11 12 13 14 15 16 lw $2, 0 F D E M WB lw $3, 0x4 add $1, $2, $3 You can use a combination of lw, add, sub, beq to test out stalling, forwarding, and flushing.","title":"Pretask:"},{"location":"CN/pipelined/pipelined/#testing-and-debugging","text":"To help you debug as well as better understand the tasks of lab 2, we've provided the waveforms for some of the tests that are running in Gradescope. Their names below correspond to the test names you see in Gradescope. You are NOT REQUIRED to match these waveforms. They are only here to help you debug the test cases and show what the proper execution of the test cases should be in order to pass. The waveforms may even contain irrelevant wires and signals, but ultimately the most important considerations for our cases are the register and memory values as these are what ensure functional correctness and the proper implementation of the 5 stage in-order pipeline. You can decode the instruction DRAM values if you want to know the actual instructions that the test cases run. Please check canvas for the sample debugging waveforms","title":"Testing and Debugging"},{"location":"CN/pipelined/pipelined/#submission","text":"To clarify: 1. First implement stalling and verify that it is working properly. 2. Once stalling works implment forwarding. Verify forwarding is working by seeing only one stall in the case with a lw RAW. This is the case where the data is only avaliable after memory stage (you want to implement stalling first in order to verify that data is not being taken incorrectly in any case) 3. Implement flushing and verify functionality For submission, please submit your tarball to Gradescope under the Lab2 Pipelining Assignment. To generate the tarball If you're using the files in the regular assignment directory, simply just run make submit on your terminal where the Makefile is located (same as running make to generate your waveform). If you're using files in the __MACOSX directory, run the bash script create_submission.sh in the root directory of the assignment. After performing either of the two actions above, you'll end up with a file titled ece3058_lab2_submission.tar.gz that you will submit to Gradescope. Make sure you add comments for the changes. Do NOT submit 3 different RTL directories for the different tasks","title":"Submission"},{"location":"CN/single_cycle/single_cycle/","text":"Go ahead and download the assignment. Required Tools for this lab \u00b6 Brew iverilog GTKwave or Scansion Lab Assignment 1 \u00b6 30 points + 20 points extra-credit Simulate the verilog MIPS processor by running make in the RTL directory. Take a screenshot of the resulting waveform Browse through the codebase and connect the different modules in the diagram below. A few lines have already been filled in for you. It might help to start by browsing mips.v . Go ahead and modify the codebase to support the MIPS slt instruction. Hint: you'll need to modify execute.v You can also refer to the truth table below . How can you verify the slt instruction is now working? What might you have to change in fetch.v ? Go ahead and implement those changes. Insert a screen capture of the waveform that shows that slt now works. Extra Credit: modify the codebase to support the MIPS j , jal , lui and ori instructions. (5 points for each working instruction. You can implement any one, few or all of these). What to Submit \u00b6 You need to submit a zip folder of your updated ``rtl\" folder. Some Notes \u00b6 Here are some things to keep in mind as you do the assignment. The verilog codebase itself isn't very representative of well designed RTL. The codebase itself reflects the architecture presented in the slides, which was unfortunately designed from a circuit level. Technically - in a real processor, you should be setting the value of a register before you use it if you haven't done so since the processor restarted. In the codebase, for simplicity from the student's perspective, each register is initialized to the value of its number index. A process block such as always executes anytime any of its arguments change state. If you have always(*) , the process block executes anytime any inputs in the module change state which effectively implements combinational logic. You should become familiar with the concatenation and replication operators here control.v could technically be a part of decode.v Truth Table \u00b6 Opcode ALUOp Operation Function ALU function ALU control 0 lw 00 load word XXXXXX add 010 1 sw 00 store word XXXXXX add 010 2 beq 01 branch equal XXXXXX subtract 110 3 R-type 10 add 100000 add 010 4 R-type 10 subtract 100010 subtract 110 5 R-type 10 AND 100100 AND 000 6 R-type 10 OR 100101 OR 001 7 R-type 10 set-on-less-than 101010 set-on-less-than 111","title":"Single Cycle MIPS Processor"},{"location":"CN/single_cycle/single_cycle/#required-tools-for-this-lab","text":"Brew iverilog GTKwave or Scansion","title":"Required Tools for this lab"},{"location":"CN/single_cycle/single_cycle/#lab-assignment-1","text":"30 points + 20 points extra-credit Simulate the verilog MIPS processor by running make in the RTL directory. Take a screenshot of the resulting waveform Browse through the codebase and connect the different modules in the diagram below. A few lines have already been filled in for you. It might help to start by browsing mips.v . Go ahead and modify the codebase to support the MIPS slt instruction. Hint: you'll need to modify execute.v You can also refer to the truth table below . How can you verify the slt instruction is now working? What might you have to change in fetch.v ? Go ahead and implement those changes. Insert a screen capture of the waveform that shows that slt now works. Extra Credit: modify the codebase to support the MIPS j , jal , lui and ori instructions. (5 points for each working instruction. You can implement any one, few or all of these).","title":"Lab Assignment 1"},{"location":"CN/single_cycle/single_cycle/#what-to-submit","text":"You need to submit a zip folder of your updated ``rtl\" folder.","title":"What to Submit"},{"location":"CN/single_cycle/single_cycle/#some-notes","text":"Here are some things to keep in mind as you do the assignment. The verilog codebase itself isn't very representative of well designed RTL. The codebase itself reflects the architecture presented in the slides, which was unfortunately designed from a circuit level. Technically - in a real processor, you should be setting the value of a register before you use it if you haven't done so since the processor restarted. In the codebase, for simplicity from the student's perspective, each register is initialized to the value of its number index. A process block such as always executes anytime any of its arguments change state. If you have always(*) , the process block executes anytime any inputs in the module change state which effectively implements combinational logic. You should become familiar with the concatenation and replication operators here control.v could technically be a part of decode.v","title":"Some Notes"},{"location":"CN/single_cycle/single_cycle/#truth-table","text":"Opcode ALUOp Operation Function ALU function ALU control 0 lw 00 load word XXXXXX add 010 1 sw 00 store word XXXXXX add 010 2 beq 01 branch equal XXXXXX subtract 110 3 R-type 10 add 100000 add 010 4 R-type 10 subtract 100010 subtract 110 5 R-type 10 AND 100100 AND 000 6 R-type 10 OR 100101 OR 001 7 R-type 10 set-on-less-than 101010 set-on-less-than 111","title":"Truth Table"},{"location":"CN/thread_scheduling/thread_scheduling/","text":"Introduction \u00b6 In this lab, you will implement a multiprocessor operating system simulator using a popular userspace threading library for linux called pthreads . The framework for the multithreaded OS simulator is nearly complete, but missing one critical component: the CPU scheduler! Your task is to implement the CPU scheduler, using three different scheduling algorithms. Note: Make sure that multiple CPU cores are enabled in your virtual machine, otherwise you will receive incorrect results. See the TAs if you need help. This can be done in virtualbox by going to: Settings > System > Processor > CPUs We have provided you with source files that constitute the framework for your simulator. You will only need to modify answers.txt and student.c . However, just because you are only modifying two files doesn't mean that you should ignore the other ones - there is helpful information in the other files. We have provided you these files: assignment.zip Scheduling Algorithms \u00b6 For your simulator, you will implement the following three CPU scheduling algorithms: First In, First Out (FIFO) - Runnable processes are kept in a ready queue. FIFO is non-preemptive; once a process begins running on a CPU, it will continue running until it either completes or blocks for I/O. Round-Robin (Extra Credit) - Similar to FIFO, except preemptive. Each process is assigned a timeslice when it is scheduled. At the end of the timeslice, if the process is still running, the process is preempted, and moved to the tail of the ready queue. Longest Remaining Time First (LRTF) (Extra Credit) - The process with the longest remaining time in its burst always gets the CPU. Shorter processes must be pre-empted if a process that has a longer burst becomes runnable. Process States \u00b6 In our OS simulation, there are five possible states for a process, which are listed in the process_state_t enum in os-sim.h: NEW - The process is being created, and has not yet begun executing. READY - The process is ready to execute, and is waiting to be scheduled on a CPU. RUNNING - The process is currently executing on a CPU. WAITING - The process has temporarily stopped executing, and is waiting on an I/O request to complete. TERMINATED - The process has completed. There is a field named state in the PCB, which must be updated with the current state of the process. The simulator will use this field to collect statistics. The Ready Queue \u00b6 On most systems, there are a large number of processes, but only one or two CPUs on which to execute them. When there are more processes ready to execute than CPUs, processes must wait in the READY state until a CPU becomes available. To keep track of the processes waiting to execute, we keep a ready queue of the processes in the READY state Since the ready queue is accessed by multiple processors, which may add and remove processes from the ready queue, the ready queue must be protected by some form of synchronization--for this lab assignment, you will use a mutex lock. The ready queue SHOULD use a different mutex than the current mutex. Scheduling Processes \u00b6 schedule() is the core function of the CPU scheduler. It is invoked whenever a CPU becomes available for running a process. schedule() must search the ready queue, select a runnable process, and call the context\\_switch() function to switch the process onto the CPU. There is a special process, the idle process, which is scheduled whenever there are no processes in the READY state. CPU Scheduler Invocation \u00b6 There are four events which will cause the simulator to invoke schedule(): yield() - A process completes its CPU operations and yields the processor to perform an I/O request. wake_up() - A process that previously yielded completes its I/O request, and is ready to perform CPU operations. wake_up() is also called when a process in the NEW state becomes runnable. preempt() - When using a LRTF or Round-Robin scheduling algorithm, a CPU-bound process may be preempted before it completes its CPU operations. terminate() - A process exits or is killed. The CPU scheduler also contains one other important function: idle() . idle() contains the code that gets by the idle process. In the real world, the idle process puts the processor in a low-power mode and waits. For our OS simulation, you will use a pthread condition variable to block the thread until a process enters the ready queue. The Simulator \u00b6 We will use pthreads to simulate an operating system on a multiprocessor computer. We will use one thread per CPU and one thread as a 'supervisor' for our simulation. The CPU threads will simulate the currently-running processes on each CPU, and the supervisor thread will print output and dispatch events to the CPU threads. Since the code you write will be called from multiple threads, the CPU scheduler you write must be thread-safe! This means that all data structures you use, including your ready queue, must be protected using mutexes. The number of CPUs is specified as a command-line parameter to the simulator. For this project, you will be performing experiments with 1, 2, and 4 CPU simulations. Also, for demonstration purposes, the simulator executes much slower than a real system would. In the real world, a CPU burst might range from one to a few hundred milliseconds, whereas in this simulator, they range from 0.2 to 2.0 seconds. Compile and run the simulator with ./os-sim 2 . After a few seconds, hit Control-C to exit. You will see the output below: The simulator generates a Gantt Chart, showing the current state of the OS at every 100ms interval. The leftmost column shows the current time, in seconds. The next three columns show the number of Running, Ready, and Waiting processes, respectively. The next two columns show the process currently running on each CPU. The rightmost column shows the processes which are currently in the I/O queue, with the head of the queue on the left and the tail of the queue on the right. As you can see, nothing is executing. This is because we have no CPU scheduler to select processes to execute! Once you complete Problem 1 and implement a basic FIFO scheduler, you will see the processes executing on the CPUs. Problem 1: FIFO Scheduler \u00b6 NOTE: Part B of each part requires you to put your answer down in answers.txt A. [50 points] - Implement the CPU scheduler using the FIFO scheduling algorithm. You may do this however you like, however, we suggest the following: Implement a thread-safe ready queue using a linked list. A linked list will allow you to reuse this ready queue for the Round-Robin and SRTF scheduling algorithms. Implement the yield(), wake_up(), and terminate() handlers. preempt() is not necessary for this stage of the project. See the overview and the comments in the code for the proper behavior of these events. Implement idle(). idle() must wait on a condition variable that is signaled whenever a process is added to the ready queue. Implement schedule(). schedule() should extract the first process in the ready queue, then call context_switch() to select the process to execute. If there are no runnable processes, schedule() should call context_switch() with a NULL pointer as the PCB to execute the idle process. Hints \u00b6 Be sure to update the state field of the PCB. The library will read this field to generate the Running, Ready, and Waiting columns, and to generate the statistics at the end of the simulation. There is a field in the PCB, next, which you may use to build linked lists of PCBs. Four of the five entry points into the scheduler (idle(), yield(), terminate(), and preempt()) should cause a new process to be scheduled on the CPU. In your handlers, be sure to call schedule(), which will select a runnable process, and then call context_switch(). When these four functions return, the library will simulate the process selected by context_switch(). context_switch() takes a timeslice parameter, which is used for preemptive scheduling algorithms. Since FIFO is non-preemptive, use -1 for this parameter to give the process an infinite timeslice. B. [5 points] Run your OS simulation with 1, 2, and 4 CPUs. Compare the total execution time of each. Is there a linear relationship between the number of CPUs and total execution time? Why or why not? Keep in mind that the execution time refers to the simulated execution time. Problem 2: Round-Robin Scheduler (Extra Credit) \u00b6 A. [20 points] Add Round-Robin scheduling functionality to your code. You should modify main() to add a command line option, -r, which selects the Round-Robin scheduling algorithm, and accepts a parameter, the length of the timeslice. For this project, timeslices are measured in tenths of seconds. E.g.: ./os-sim <# CPUs> -r 5 should run a Round-Robin scheduler with timeslices of 500 ms. While: ./os-sim <# of CPUs> should continue to run a FIFO scheduler. To specify a timeslice when scheduling a process, use the timeslice parameter of context_switch(). The simulator will automatically preempt the process and call your preempt() handler if the process executes on the CPU for the length of the timeslice without terminating or yielding for I/O. Note: You need to implement force_preempt() for this scheduler. The force_preempt() function preempts a running process before its timeslice expires. B. [5 points] Run your Round-Robin scheduler with timeslices of 800ms, 600ms, 400ms, and 200ms. Use only one CPU for your tests. Compare the statistics at the end of the simulation. Show that the total waiting time decreases with shorter timeslices. However, in a real OS, the shortest timeslice possible is usually not the best choice. Why not? Problem 3: Longest Remaining Time First Scheduler (Extra Credit) \u00b6 A. [20 points] Add LRTF scheduling to your code. You should modify main() to add a command line option, -l, which selects the LRTF scheduling algorithm. E.g.: ./os-sim <# CPUs> -l should run a LRTF scheduler. While: ./os-sim <# of CPUs> should continue to run a FIFO scheduler. Make sure the default FIFO and Round Robin schedulers should continue to work! The scheduler should use the time_remaining field of the PCB to prioritize processes that have the longer remaining time in their CPU burst. For LRTF scheduling, you will need to make use of the current[] array and force_preempt() function. The current[] array should be used to keep track of the process currently executing on each CPU. Since this array is accessed by multiple CPU threads, it must be protected by a mutex. current_mutex has been provided for you. Note: You need to implement force_preempt() for this scheduler. The force_preempt() function preempts a running process before its timeslice expires. Your wake_up() handler should make use of this function to preempt a process when a process with higher time remaining needs a CPU. B. [10 points] - (B.1) While it is easy to simulate an LRTF algorithm in the simulator, it is essentially impossible to implement precisely in real life and is thus usually approximated. Why is this the case? - (B.2) Run both scheduling algorithms using one CPU and compare the total waiting times. Which one has the lowest? Can you think of a reason why? Deliverables \u00b6 NOTE: Each Problem has two parts (labeled A and B). The first is the actual implementation, and the second is a question linked to the scheduling algorithm you are implementing. Make sure you complete both. Note/Hint regarding Extra Credit vs. Other Parts. The total lab is worth 55 points. Parts B and C are for extra credit. Part A (55 points) is compulsory, and necessary for Part B (25 points) and Part C (30 points) to even work. You will still need to implement the force_prempt() function for either of Part B or C to work. Parts B and C are independent - if your final solution works for Parts A and C, not Part B (for instance), you will get 55+30 = 85 points. Type `make submit' to generate a tarball containing all the files needed for submission. Please turn in <GT_USERNAME>-ece3058-lab-ts.tar.gz This tarball should contain: answers.txt - Short answers to questions from above. Makefile - Working one provided for you; don't break it. src/os-sim.c - Code for the operating system simulator. src/os-sim.h - Header file for the simulator. src/process.c - Descriptions of the simulated processes. src/process.h - Header file for the process data. src/student.c - Your code for the scheduler. src/student.h - Header file for your scheduler code. Keep your answers detailed enough to cover the question, including support from simulator results if appropriate. Don't write a book; but if you're not sure about an answer, err on the side of giving us too much information.","title":"Thread Scheduling Lab"},{"location":"CN/thread_scheduling/thread_scheduling/#introduction","text":"In this lab, you will implement a multiprocessor operating system simulator using a popular userspace threading library for linux called pthreads . The framework for the multithreaded OS simulator is nearly complete, but missing one critical component: the CPU scheduler! Your task is to implement the CPU scheduler, using three different scheduling algorithms. Note: Make sure that multiple CPU cores are enabled in your virtual machine, otherwise you will receive incorrect results. See the TAs if you need help. This can be done in virtualbox by going to: Settings > System > Processor > CPUs We have provided you with source files that constitute the framework for your simulator. You will only need to modify answers.txt and student.c . However, just because you are only modifying two files doesn't mean that you should ignore the other ones - there is helpful information in the other files. We have provided you these files: assignment.zip","title":"Introduction"},{"location":"CN/thread_scheduling/thread_scheduling/#scheduling-algorithms","text":"For your simulator, you will implement the following three CPU scheduling algorithms: First In, First Out (FIFO) - Runnable processes are kept in a ready queue. FIFO is non-preemptive; once a process begins running on a CPU, it will continue running until it either completes or blocks for I/O. Round-Robin (Extra Credit) - Similar to FIFO, except preemptive. Each process is assigned a timeslice when it is scheduled. At the end of the timeslice, if the process is still running, the process is preempted, and moved to the tail of the ready queue. Longest Remaining Time First (LRTF) (Extra Credit) - The process with the longest remaining time in its burst always gets the CPU. Shorter processes must be pre-empted if a process that has a longer burst becomes runnable.","title":"Scheduling Algorithms"},{"location":"CN/thread_scheduling/thread_scheduling/#process-states","text":"In our OS simulation, there are five possible states for a process, which are listed in the process_state_t enum in os-sim.h: NEW - The process is being created, and has not yet begun executing. READY - The process is ready to execute, and is waiting to be scheduled on a CPU. RUNNING - The process is currently executing on a CPU. WAITING - The process has temporarily stopped executing, and is waiting on an I/O request to complete. TERMINATED - The process has completed. There is a field named state in the PCB, which must be updated with the current state of the process. The simulator will use this field to collect statistics.","title":"Process States"},{"location":"CN/thread_scheduling/thread_scheduling/#the-ready-queue","text":"On most systems, there are a large number of processes, but only one or two CPUs on which to execute them. When there are more processes ready to execute than CPUs, processes must wait in the READY state until a CPU becomes available. To keep track of the processes waiting to execute, we keep a ready queue of the processes in the READY state Since the ready queue is accessed by multiple processors, which may add and remove processes from the ready queue, the ready queue must be protected by some form of synchronization--for this lab assignment, you will use a mutex lock. The ready queue SHOULD use a different mutex than the current mutex.","title":"The Ready Queue"},{"location":"CN/thread_scheduling/thread_scheduling/#scheduling-processes","text":"schedule() is the core function of the CPU scheduler. It is invoked whenever a CPU becomes available for running a process. schedule() must search the ready queue, select a runnable process, and call the context\\_switch() function to switch the process onto the CPU. There is a special process, the idle process, which is scheduled whenever there are no processes in the READY state.","title":"Scheduling Processes"},{"location":"CN/thread_scheduling/thread_scheduling/#cpu-scheduler-invocation","text":"There are four events which will cause the simulator to invoke schedule(): yield() - A process completes its CPU operations and yields the processor to perform an I/O request. wake_up() - A process that previously yielded completes its I/O request, and is ready to perform CPU operations. wake_up() is also called when a process in the NEW state becomes runnable. preempt() - When using a LRTF or Round-Robin scheduling algorithm, a CPU-bound process may be preempted before it completes its CPU operations. terminate() - A process exits or is killed. The CPU scheduler also contains one other important function: idle() . idle() contains the code that gets by the idle process. In the real world, the idle process puts the processor in a low-power mode and waits. For our OS simulation, you will use a pthread condition variable to block the thread until a process enters the ready queue.","title":"CPU Scheduler Invocation"},{"location":"CN/thread_scheduling/thread_scheduling/#the-simulator","text":"We will use pthreads to simulate an operating system on a multiprocessor computer. We will use one thread per CPU and one thread as a 'supervisor' for our simulation. The CPU threads will simulate the currently-running processes on each CPU, and the supervisor thread will print output and dispatch events to the CPU threads. Since the code you write will be called from multiple threads, the CPU scheduler you write must be thread-safe! This means that all data structures you use, including your ready queue, must be protected using mutexes. The number of CPUs is specified as a command-line parameter to the simulator. For this project, you will be performing experiments with 1, 2, and 4 CPU simulations. Also, for demonstration purposes, the simulator executes much slower than a real system would. In the real world, a CPU burst might range from one to a few hundred milliseconds, whereas in this simulator, they range from 0.2 to 2.0 seconds. Compile and run the simulator with ./os-sim 2 . After a few seconds, hit Control-C to exit. You will see the output below: The simulator generates a Gantt Chart, showing the current state of the OS at every 100ms interval. The leftmost column shows the current time, in seconds. The next three columns show the number of Running, Ready, and Waiting processes, respectively. The next two columns show the process currently running on each CPU. The rightmost column shows the processes which are currently in the I/O queue, with the head of the queue on the left and the tail of the queue on the right. As you can see, nothing is executing. This is because we have no CPU scheduler to select processes to execute! Once you complete Problem 1 and implement a basic FIFO scheduler, you will see the processes executing on the CPUs.","title":"The Simulator"},{"location":"CN/thread_scheduling/thread_scheduling/#problem-1-fifo-scheduler","text":"NOTE: Part B of each part requires you to put your answer down in answers.txt A. [50 points] - Implement the CPU scheduler using the FIFO scheduling algorithm. You may do this however you like, however, we suggest the following: Implement a thread-safe ready queue using a linked list. A linked list will allow you to reuse this ready queue for the Round-Robin and SRTF scheduling algorithms. Implement the yield(), wake_up(), and terminate() handlers. preempt() is not necessary for this stage of the project. See the overview and the comments in the code for the proper behavior of these events. Implement idle(). idle() must wait on a condition variable that is signaled whenever a process is added to the ready queue. Implement schedule(). schedule() should extract the first process in the ready queue, then call context_switch() to select the process to execute. If there are no runnable processes, schedule() should call context_switch() with a NULL pointer as the PCB to execute the idle process.","title":"Problem 1: FIFO Scheduler"},{"location":"CN/thread_scheduling/thread_scheduling/#hints","text":"Be sure to update the state field of the PCB. The library will read this field to generate the Running, Ready, and Waiting columns, and to generate the statistics at the end of the simulation. There is a field in the PCB, next, which you may use to build linked lists of PCBs. Four of the five entry points into the scheduler (idle(), yield(), terminate(), and preempt()) should cause a new process to be scheduled on the CPU. In your handlers, be sure to call schedule(), which will select a runnable process, and then call context_switch(). When these four functions return, the library will simulate the process selected by context_switch(). context_switch() takes a timeslice parameter, which is used for preemptive scheduling algorithms. Since FIFO is non-preemptive, use -1 for this parameter to give the process an infinite timeslice. B. [5 points] Run your OS simulation with 1, 2, and 4 CPUs. Compare the total execution time of each. Is there a linear relationship between the number of CPUs and total execution time? Why or why not? Keep in mind that the execution time refers to the simulated execution time.","title":"Hints"},{"location":"CN/thread_scheduling/thread_scheduling/#problem-2-round-robin-scheduler-extra-credit","text":"A. [20 points] Add Round-Robin scheduling functionality to your code. You should modify main() to add a command line option, -r, which selects the Round-Robin scheduling algorithm, and accepts a parameter, the length of the timeslice. For this project, timeslices are measured in tenths of seconds. E.g.: ./os-sim <# CPUs> -r 5 should run a Round-Robin scheduler with timeslices of 500 ms. While: ./os-sim <# of CPUs> should continue to run a FIFO scheduler. To specify a timeslice when scheduling a process, use the timeslice parameter of context_switch(). The simulator will automatically preempt the process and call your preempt() handler if the process executes on the CPU for the length of the timeslice without terminating or yielding for I/O. Note: You need to implement force_preempt() for this scheduler. The force_preempt() function preempts a running process before its timeslice expires. B. [5 points] Run your Round-Robin scheduler with timeslices of 800ms, 600ms, 400ms, and 200ms. Use only one CPU for your tests. Compare the statistics at the end of the simulation. Show that the total waiting time decreases with shorter timeslices. However, in a real OS, the shortest timeslice possible is usually not the best choice. Why not?","title":"Problem 2: Round-Robin Scheduler (Extra Credit)"},{"location":"CN/thread_scheduling/thread_scheduling/#problem-3-longest-remaining-time-first-scheduler-extra-credit","text":"A. [20 points] Add LRTF scheduling to your code. You should modify main() to add a command line option, -l, which selects the LRTF scheduling algorithm. E.g.: ./os-sim <# CPUs> -l should run a LRTF scheduler. While: ./os-sim <# of CPUs> should continue to run a FIFO scheduler. Make sure the default FIFO and Round Robin schedulers should continue to work! The scheduler should use the time_remaining field of the PCB to prioritize processes that have the longer remaining time in their CPU burst. For LRTF scheduling, you will need to make use of the current[] array and force_preempt() function. The current[] array should be used to keep track of the process currently executing on each CPU. Since this array is accessed by multiple CPU threads, it must be protected by a mutex. current_mutex has been provided for you. Note: You need to implement force_preempt() for this scheduler. The force_preempt() function preempts a running process before its timeslice expires. Your wake_up() handler should make use of this function to preempt a process when a process with higher time remaining needs a CPU. B. [10 points] - (B.1) While it is easy to simulate an LRTF algorithm in the simulator, it is essentially impossible to implement precisely in real life and is thus usually approximated. Why is this the case? - (B.2) Run both scheduling algorithms using one CPU and compare the total waiting times. Which one has the lowest? Can you think of a reason why?","title":"Problem 3: Longest Remaining Time First Scheduler (Extra Credit)"},{"location":"CN/thread_scheduling/thread_scheduling/#deliverables","text":"NOTE: Each Problem has two parts (labeled A and B). The first is the actual implementation, and the second is a question linked to the scheduling algorithm you are implementing. Make sure you complete both. Note/Hint regarding Extra Credit vs. Other Parts. The total lab is worth 55 points. Parts B and C are for extra credit. Part A (55 points) is compulsory, and necessary for Part B (25 points) and Part C (30 points) to even work. You will still need to implement the force_prempt() function for either of Part B or C to work. Parts B and C are independent - if your final solution works for Parts A and C, not Part B (for instance), you will get 55+30 = 85 points. Type `make submit' to generate a tarball containing all the files needed for submission. Please turn in <GT_USERNAME>-ece3058-lab-ts.tar.gz This tarball should contain: answers.txt - Short answers to questions from above. Makefile - Working one provided for you; don't break it. src/os-sim.c - Code for the operating system simulator. src/os-sim.h - Header file for the simulator. src/process.c - Descriptions of the simulated processes. src/process.h - Header file for the process data. src/student.c - Your code for the scheduler. src/student.h - Header file for your scheduler code. Keep your answers detailed enough to cover the question, including support from simulator results if appropriate. Don't write a book; but if you're not sure about an answer, err on the side of giving us too much information.","title":"Deliverables"},{"location":"CN/virtual_memory/virtual_memory/","text":"Lab Description \u00b6 In this assignment, you will be implementing a virtual memory system simulator. The lab files can be downloaded here: assignment.zip You have been given a simulator which is missing some critical parts. You will be responsible for implementing these parts. Detailed instructions are in the files to guide you along the way. If you are having trouble, we strongly suggest that you take the time to read about the material from the class notes. Memory Organization \u00b6 The simulator simulates a system with 1MB of physical memory. Throughout the simulator, you can access physical memory through the global variable uint8_t mem[] (an array of bytes called mem ). You have access to, and will manage, the entirety of physical memory. The system has a 24-bit virtual address space and memory is divided into 16KB pages . Like a real computer, your page tables and data structures live in physical memory too! Both the page table and the frame table fit in a single page in memory, and you'll be responsible for placing these structures into memory. Note: Since user data and operating system structures (such as the frame table and page tables), coexist in the same physical memory, we must have some way to differentiate between the two, and keep user pages from taking over system pages. Modern day operating systems often solve this problem by dividing physical memory up into a kernal space and a user space , where kernal space typically lies below a certain address and user space above. For this project, we'll take a simpler approach: Every frame has a protected bit, which we'll set to 1 for system frames and 0 for user frames. Key files \u00b6 There are 7 tasks in the files that you will complete. The files that you will be changing are the following: page_splitting.h : Break down a virtual address into its components. paging.c : Initialize any necessary bookkeeping and implement address translation. page_fault.c : Implement the page fault handler. page_replacement.c : Write frame eviction. stats.c : Calculate the Average Access Time of the memory system (AAT) You will fill out the functions in these files, and then validate your output against the given outputs. If you are struggling with writing the code, then step back and review the concepts. Be sure to start early, ask Piazza questions, and visit us in office hours for extra help! Task 1: Page Splitting \u00b6 In most modern operating systems, user programs access memory using virtual addresses The hardware and the operating system work together to turn the virtual address into a physical address, which can then be used to address into physical memory. The first step of this process is to translate the virtual address into two parts: The higher order bits for the VPN, and the lower bits for the page offset. In page_splitting.h , complete the vaddr_vpn and vaddr_offset functions. These will be used to split a virtual address into its corresponding page number and page offset. You will need to use the parameters for the virtual memory system defined in pagesim.h ( PAGE_SIZE , MEM_SIZE , etc.). Task 2: Initialization \u00b6 Before we can begin accessing pages, we will need to set up the frame table (sometimes known as a reverse lookup table ). After that, for every process that starts, you'll need to give it a page table. For simplicity, we always place the frame table in physical frame 0 (don't forget to mark this frame as protected ). Since this frame table belongs in a frame, we want to make sure that we will never evict the frame table . To do this, we set a protected bit. During your page replacement, you will need to make sure that you never choose a protected frame as your victim. Since processes can start and stop any time during your computer's lifetime, we must be a little more sophisticated in choosing which frames to place their page tables in. For now, we won't worry about the logistics of choosing a frame--just call the free_frame function you'll write later in page_replacement.c . (Do we ever want to evict the frame containing the page table while the process is running?) Your task is to fill out the following functions in paging.c : system_init() proc_init() Each function listed above has helpful comments in the file. You may add any global variables or helper functions you deem necessary. Each frame contains PAGE_SIZE bytes of data, therefore to access the start of the i i -th frame in memory, you can use mem + (i * PAGE_SIZE) . Task 3: Context Switches and the Page Table Base Register \u00b6 As you know, every process has its own page table. When the processor needs to perform a page lookup, it must know which page table to look in. This is where the page table base register (PTBR) comes in. In the simulator, you can access the page table base register through the global variable pfn_t PTBR . Implement the context_switch function in paging.c . Your job is to update the PTBR to refer to the new process's page table. This function will be very simple. Going forward, pay close attention to the type of the PTBR. The PTBR holds a physical frame number (PFN), not a virtual address. Think about why this must be. Task 4: Reading and Writing Memory \u00b6 The ability to allocate physical frames is useless if we cannot read or write to them. In this section, you will add functionality for reading and writing individual bytes to memory. Because processes operate on a virtual memory space, it is necessary to first translate a virtual address supplied by a process into its corresponding physical address, which then will be used access the location in physical memory. This is accomplished using the page table, which contains all of a process's mappings from virtual addresses to physical addresses. Implement the mem_access function in paging.c . You will need to use the passed-in virtual address to find the correct page table entry and the offset within the corresponding page. **HINT:*8 Use the page splitting functions that you wrote earlier in the project. Once you have identified the correct page table entry, you must use this to find the corresponding physical frame and its address in memory, and then perform the read or write at the proper location within the page. (Remember that the simulator's memory is represented by the mem array). Keep in mind that not all entries in a process's page table have necessarily been mapped. Entries not yet mapped are marked as invalid, and an attempt to access an invalid address should generate a page fault. You will write the page_fault() function in the next section, so for now just assume that it has successfully allocated a page for that address after it returns. When performing a memory access to an address, you must also make sure to set the mark the containing frame as referenced in the appropriate frame table entry, as well as marking the containing page as dirty in the process's page table. These bits will be used later when deciding on what pages should be evicted first, and if an evicted page needs to be written to the disk to preserve its content. Task 5: Page Fault. Task 6: Eviction and Replacement \u00b6 Recall that when a CPU encounters an invalid VPN to PFN mapping in the page table, a page fault occurs. The OS allocates a new frame for the page by either finding an empty frame or evicting a page from a frame that is in use. In this section, you will be implementing a page fault and replacement mechanism. Implement the function page_fault() in page_fault.c . A page fault occurs when the CPU attempts to translate a virtual address, but finds no valid entry in the page table for the VPN. To handle the page fault, you must find a frame to hold the page (call free_frame() , then update the page table and frame table to reference that frame. Next, we will turn our attention to the eviction process in page_replacement.c . If you ask the system for a free frame when all the frames are in use, the operating system must select an in-use frame and re-use it, evicting any existing page that was previously using the frame. Implement this logic in free_frame() . You must update the mappings from VPN to PFN in the current process' page table as well as invalidate the mapping the evicted process' page table to resolve the page fault. ` If the evicted page is dirty, you will need to swap it out and write its contents to disk. To do so, we provide a method called swap_write() , where you can pass in a pointer to the victim's pagetable entry and a pointer to the frame in memory. Similarly, after you map a new frame to a faulting page, you should check if the page has a swap entry assigned, and call swap_read() if so. Swap space effectively extends the memory of your system. If physical memory is full, the operating system kicks some frames to the hard disk to accommodate others. When the swapped frames are needed again, they are restored from the disk into physical mem`ory. Task 7: Finishing a Process \u00b6 If a process finishes, we don't want it to hold onto any of the frames that it was using. We should release any frames so that other processes can use them. Also: If the process is no longer executing, can we release the page table? As part of cleaning up a process, you will need to also free any swap entries that have been mapped to pages. You can use swap_free() to accomplish this. Implement the function proc_cleanup() in paging.c . Computing AAT \u00b6 In the final section of this project, you will be computing some statistics. writes - The total number of accesses that were writes reads - The total number of accesses that were reads accesses - The total number of accesses to the memory system page\\_faults - Accesses that resulted in a page fault writes\\_to\\_disk - How many times you wrote to disk aat - The average access time of the memory system We will give you some numbers that are necessary to calculate the AAT: ``MEMORY_READ_TIME - The time taken to access memory SET BY SIMULATOR ``DISK_PAGE_READ_TIME - The time taken to read a page from the disk SET BY SIMULATOR ``DISK_PAGE_WRITE_TIME - The time taken to write to disk SET BY SIMULATOR You will need to implement the compute_stats() function in stats.c . How to Run / Debug Your Code \u00b6 Environment \u00b6 Your code should compile on the ECE linux machines. You can develop on whatever environment you prefer, so long as your code also works in the ECE machines. Non-compiling solutions will receive a 0! Compiling and Running \u00b6 We have provided a Makefile that will run gcc for you. To compile your code with no optimizations (which you should do while developing, it will make debugging easier), run $ make $./vm-sim -i traces/<trace>.trace We highly recommend starting with simple.trace . This will allow you to test the core functionality of your virtual memory simulator without worrying about context switches or writebacks, as this trace contains neither. Corruption Checker \u00b6 One challenge of working with any memory-management system is that your system can easily corrupt its own data structures if it misbehaves! Such corruption issues can easily hide until many cycles later, when they manifest as seemingly unrelated crashes later. To help with detecting these issues, we've included a corruption check mode that aggressively verifies your data structures after every cycle. To use the corruption checker, run the simulator with the -c argument: $./vm-sim -c -i traces/<trace>.trace Debugging Tips \u00b6 If your program is crashing or misbehaving, you can use GDB to locate the bug. GDB is a command line interface that will allow you to set breakpoints, step through your code, see variable values, and identify segfaults. There are tons of online guides, \\href{ http://condor.depaul.edu/glancast/373class/docs/gdb.html#Setting_Breakpoints}{click here} ( http://condor.depaul.edu/glancast/373class/docs/gdb.html ) for one. To compile with debugging information, you must build the program with make debug : $ make clean $ make debug To start your program in gdb, run: $ gdb ./vm-sim Within gdb, you can run your program with the run command, see below for an example: $ (gdb) r -i traces/<trace>.trace If you use the corruption checker, you can set a breakpoint on panic() and use a backtrace to discover the context in which the panic occurred: $ (gdb) break panic $ (gdb) r -i traces/<trace>.trace ! (wait for GDB to stop at the breakpoint) $ (gdb) backtrace $ (gdb) frame N ! where N is the frame number you want to examine Feel free to ask about gdb and how to use it in office hours and on Piazza. Do not ask a TA or post on Piazza about a segfault without first running your program through GDB. Verifying Your Solution \u00b6 On execution, the simulator will output data read/write values. To check against our solutions, run $ ./vm-sim -i traces/<trace>.trace > my_output.log $ diff my_output.log outputs/<trace>.log We have released the expected outputs for some traces in outputs. NOTE: To get full credit you must completely match the TA generated outputs for each trace. How to Submit \u00b6 Run make submit to automatically package your project for submission. Submit the resulting tar.gz zip on Gradescope to run the autograder.","title":"Virtual Memory Lab"},{"location":"CN/virtual_memory/virtual_memory/#lab-description","text":"In this assignment, you will be implementing a virtual memory system simulator. The lab files can be downloaded here: assignment.zip You have been given a simulator which is missing some critical parts. You will be responsible for implementing these parts. Detailed instructions are in the files to guide you along the way. If you are having trouble, we strongly suggest that you take the time to read about the material from the class notes.","title":"Lab Description"},{"location":"CN/virtual_memory/virtual_memory/#memory-organization","text":"The simulator simulates a system with 1MB of physical memory. Throughout the simulator, you can access physical memory through the global variable uint8_t mem[] (an array of bytes called mem ). You have access to, and will manage, the entirety of physical memory. The system has a 24-bit virtual address space and memory is divided into 16KB pages . Like a real computer, your page tables and data structures live in physical memory too! Both the page table and the frame table fit in a single page in memory, and you'll be responsible for placing these structures into memory. Note: Since user data and operating system structures (such as the frame table and page tables), coexist in the same physical memory, we must have some way to differentiate between the two, and keep user pages from taking over system pages. Modern day operating systems often solve this problem by dividing physical memory up into a kernal space and a user space , where kernal space typically lies below a certain address and user space above. For this project, we'll take a simpler approach: Every frame has a protected bit, which we'll set to 1 for system frames and 0 for user frames.","title":"Memory Organization"},{"location":"CN/virtual_memory/virtual_memory/#key-files","text":"There are 7 tasks in the files that you will complete. The files that you will be changing are the following: page_splitting.h : Break down a virtual address into its components. paging.c : Initialize any necessary bookkeeping and implement address translation. page_fault.c : Implement the page fault handler. page_replacement.c : Write frame eviction. stats.c : Calculate the Average Access Time of the memory system (AAT) You will fill out the functions in these files, and then validate your output against the given outputs. If you are struggling with writing the code, then step back and review the concepts. Be sure to start early, ask Piazza questions, and visit us in office hours for extra help!","title":"Key files"},{"location":"CN/virtual_memory/virtual_memory/#task-1-page-splitting","text":"In most modern operating systems, user programs access memory using virtual addresses The hardware and the operating system work together to turn the virtual address into a physical address, which can then be used to address into physical memory. The first step of this process is to translate the virtual address into two parts: The higher order bits for the VPN, and the lower bits for the page offset. In page_splitting.h , complete the vaddr_vpn and vaddr_offset functions. These will be used to split a virtual address into its corresponding page number and page offset. You will need to use the parameters for the virtual memory system defined in pagesim.h ( PAGE_SIZE , MEM_SIZE , etc.).","title":"Task 1: Page Splitting"},{"location":"CN/virtual_memory/virtual_memory/#task-2-initialization","text":"Before we can begin accessing pages, we will need to set up the frame table (sometimes known as a reverse lookup table ). After that, for every process that starts, you'll need to give it a page table. For simplicity, we always place the frame table in physical frame 0 (don't forget to mark this frame as protected ). Since this frame table belongs in a frame, we want to make sure that we will never evict the frame table . To do this, we set a protected bit. During your page replacement, you will need to make sure that you never choose a protected frame as your victim. Since processes can start and stop any time during your computer's lifetime, we must be a little more sophisticated in choosing which frames to place their page tables in. For now, we won't worry about the logistics of choosing a frame--just call the free_frame function you'll write later in page_replacement.c . (Do we ever want to evict the frame containing the page table while the process is running?) Your task is to fill out the following functions in paging.c : system_init() proc_init() Each function listed above has helpful comments in the file. You may add any global variables or helper functions you deem necessary. Each frame contains PAGE_SIZE bytes of data, therefore to access the start of the i i -th frame in memory, you can use mem + (i * PAGE_SIZE) .","title":"Task 2: Initialization"},{"location":"CN/virtual_memory/virtual_memory/#task-3-context-switches-and-the-page-table-base-register","text":"As you know, every process has its own page table. When the processor needs to perform a page lookup, it must know which page table to look in. This is where the page table base register (PTBR) comes in. In the simulator, you can access the page table base register through the global variable pfn_t PTBR . Implement the context_switch function in paging.c . Your job is to update the PTBR to refer to the new process's page table. This function will be very simple. Going forward, pay close attention to the type of the PTBR. The PTBR holds a physical frame number (PFN), not a virtual address. Think about why this must be.","title":"Task 3: Context Switches and the Page Table Base Register"},{"location":"CN/virtual_memory/virtual_memory/#task-4-reading-and-writing-memory","text":"The ability to allocate physical frames is useless if we cannot read or write to them. In this section, you will add functionality for reading and writing individual bytes to memory. Because processes operate on a virtual memory space, it is necessary to first translate a virtual address supplied by a process into its corresponding physical address, which then will be used access the location in physical memory. This is accomplished using the page table, which contains all of a process's mappings from virtual addresses to physical addresses. Implement the mem_access function in paging.c . You will need to use the passed-in virtual address to find the correct page table entry and the offset within the corresponding page. **HINT:*8 Use the page splitting functions that you wrote earlier in the project. Once you have identified the correct page table entry, you must use this to find the corresponding physical frame and its address in memory, and then perform the read or write at the proper location within the page. (Remember that the simulator's memory is represented by the mem array). Keep in mind that not all entries in a process's page table have necessarily been mapped. Entries not yet mapped are marked as invalid, and an attempt to access an invalid address should generate a page fault. You will write the page_fault() function in the next section, so for now just assume that it has successfully allocated a page for that address after it returns. When performing a memory access to an address, you must also make sure to set the mark the containing frame as referenced in the appropriate frame table entry, as well as marking the containing page as dirty in the process's page table. These bits will be used later when deciding on what pages should be evicted first, and if an evicted page needs to be written to the disk to preserve its content.","title":"Task 4: Reading and Writing Memory"},{"location":"CN/virtual_memory/virtual_memory/#task-5-page-fault-task-6-eviction-and-replacement","text":"Recall that when a CPU encounters an invalid VPN to PFN mapping in the page table, a page fault occurs. The OS allocates a new frame for the page by either finding an empty frame or evicting a page from a frame that is in use. In this section, you will be implementing a page fault and replacement mechanism. Implement the function page_fault() in page_fault.c . A page fault occurs when the CPU attempts to translate a virtual address, but finds no valid entry in the page table for the VPN. To handle the page fault, you must find a frame to hold the page (call free_frame() , then update the page table and frame table to reference that frame. Next, we will turn our attention to the eviction process in page_replacement.c . If you ask the system for a free frame when all the frames are in use, the operating system must select an in-use frame and re-use it, evicting any existing page that was previously using the frame. Implement this logic in free_frame() . You must update the mappings from VPN to PFN in the current process' page table as well as invalidate the mapping the evicted process' page table to resolve the page fault. ` If the evicted page is dirty, you will need to swap it out and write its contents to disk. To do so, we provide a method called swap_write() , where you can pass in a pointer to the victim's pagetable entry and a pointer to the frame in memory. Similarly, after you map a new frame to a faulting page, you should check if the page has a swap entry assigned, and call swap_read() if so. Swap space effectively extends the memory of your system. If physical memory is full, the operating system kicks some frames to the hard disk to accommodate others. When the swapped frames are needed again, they are restored from the disk into physical mem`ory.","title":"Task 5: Page Fault. Task 6: Eviction and Replacement"},{"location":"CN/virtual_memory/virtual_memory/#task-7-finishing-a-process","text":"If a process finishes, we don't want it to hold onto any of the frames that it was using. We should release any frames so that other processes can use them. Also: If the process is no longer executing, can we release the page table? As part of cleaning up a process, you will need to also free any swap entries that have been mapped to pages. You can use swap_free() to accomplish this. Implement the function proc_cleanup() in paging.c .","title":"Task 7: Finishing a Process"},{"location":"CN/virtual_memory/virtual_memory/#computing-aat","text":"In the final section of this project, you will be computing some statistics. writes - The total number of accesses that were writes reads - The total number of accesses that were reads accesses - The total number of accesses to the memory system page\\_faults - Accesses that resulted in a page fault writes\\_to\\_disk - How many times you wrote to disk aat - The average access time of the memory system We will give you some numbers that are necessary to calculate the AAT: ``MEMORY_READ_TIME - The time taken to access memory SET BY SIMULATOR ``DISK_PAGE_READ_TIME - The time taken to read a page from the disk SET BY SIMULATOR ``DISK_PAGE_WRITE_TIME - The time taken to write to disk SET BY SIMULATOR You will need to implement the compute_stats() function in stats.c .","title":"Computing AAT"},{"location":"CN/virtual_memory/virtual_memory/#how-to-run-debug-your-code","text":"","title":"How to Run / Debug Your Code"},{"location":"CN/virtual_memory/virtual_memory/#environment","text":"Your code should compile on the ECE linux machines. You can develop on whatever environment you prefer, so long as your code also works in the ECE machines. Non-compiling solutions will receive a 0!","title":"Environment"},{"location":"CN/virtual_memory/virtual_memory/#compiling-and-running","text":"We have provided a Makefile that will run gcc for you. To compile your code with no optimizations (which you should do while developing, it will make debugging easier), run $ make $./vm-sim -i traces/<trace>.trace We highly recommend starting with simple.trace . This will allow you to test the core functionality of your virtual memory simulator without worrying about context switches or writebacks, as this trace contains neither.","title":"Compiling and Running"},{"location":"CN/virtual_memory/virtual_memory/#corruption-checker","text":"One challenge of working with any memory-management system is that your system can easily corrupt its own data structures if it misbehaves! Such corruption issues can easily hide until many cycles later, when they manifest as seemingly unrelated crashes later. To help with detecting these issues, we've included a corruption check mode that aggressively verifies your data structures after every cycle. To use the corruption checker, run the simulator with the -c argument: $./vm-sim -c -i traces/<trace>.trace","title":"Corruption Checker"},{"location":"CN/virtual_memory/virtual_memory/#debugging-tips","text":"If your program is crashing or misbehaving, you can use GDB to locate the bug. GDB is a command line interface that will allow you to set breakpoints, step through your code, see variable values, and identify segfaults. There are tons of online guides, \\href{ http://condor.depaul.edu/glancast/373class/docs/gdb.html#Setting_Breakpoints}{click here} ( http://condor.depaul.edu/glancast/373class/docs/gdb.html ) for one. To compile with debugging information, you must build the program with make debug : $ make clean $ make debug To start your program in gdb, run: $ gdb ./vm-sim Within gdb, you can run your program with the run command, see below for an example: $ (gdb) r -i traces/<trace>.trace If you use the corruption checker, you can set a breakpoint on panic() and use a backtrace to discover the context in which the panic occurred: $ (gdb) break panic $ (gdb) r -i traces/<trace>.trace ! (wait for GDB to stop at the breakpoint) $ (gdb) backtrace $ (gdb) frame N ! where N is the frame number you want to examine Feel free to ask about gdb and how to use it in office hours and on Piazza. Do not ask a TA or post on Piazza about a segfault without first running your program through GDB.","title":"Debugging Tips"},{"location":"CN/virtual_memory/virtual_memory/#verifying-your-solution","text":"On execution, the simulator will output data read/write values. To check against our solutions, run $ ./vm-sim -i traces/<trace>.trace > my_output.log $ diff my_output.log outputs/<trace>.log We have released the expected outputs for some traces in outputs. NOTE: To get full credit you must completely match the TA generated outputs for each trace.","title":"Verifying Your Solution"},{"location":"CN/virtual_memory/virtual_memory/#how-to-submit","text":"Run make submit to automatically package your project for submission. Submit the resulting tar.gz zip on Gradescope to run the autograder.","title":"How to Submit"},{"location":"DS/Full_ISA/ISA/","text":"MIPs ISA Release 2 \u00b6 All 199 instructions from MIPs ISA Release 2 are summarized below. In this class, we implement only about 7 of them. The full MIPS ISA reference documents are listed below. Volume Volume I: Introduction to the MIPS32 Architecture Volume II: The MIPS32 Instruction Set Volume III: The MIPS32 Privileged Resource Architecture CPU Arithmetic Instructions \u00b6 Mnemonic Instruction Misc. 0 ADD Add Word 1 ADDI Add Immediate Word 2 ADDIU Add Immediate Unsigned Word 3 ADDU Add Unsigned Word 4 CLO Count Leading Ones in Word 5 CLZ Count Leading Zeros in Word 6 DIV Divide Word 7 DIVU Divide Unsigned Word 8 MADD Multiply and Add Word to Hi, Lo 9 MADDU Multiply and Add Unsigned Word to Hi, Lo 10 MSUB Multiply and Subtract Word to Hi, Lo 11 MSUBU Multiply and Subtract Unsigned Word to Hi, Lo 12 MUL Multiply Word to GPR 13 MULT Multiply Word 14 MULTU Multiply Unsigned Word 15 SEB Sign-Extend Byte Release 2 Only 16 SEH Sign-Extend Halftword Release 2 Only 17 SLT Set on Less Than 18 SLTI Set on Less Than Immediate 19 SLTIU Set on Less Than Immediate Unsigned 20 SLTU Set on Less Than Unsigned 21 SUB Subtract Word 22 SUBU Subtract Unsigned Word CPU Branch and Jump Instructions \u00b6 Mnemonic Instruction Misc. 0 B Unconditional Branch 1 BAL Branch and Link 2 BEQ Branch on Equal 3 BGEZ Branch on Greater Than or Equal to Zero 4 BGEZAL Branch on Greater Than or Equal to Zero and Link 5 BGTZ Branch on Greater Than Zero 6 BLEZ Branch on Less Than or Equal to Zero 7 BLTZ Branch on Less Than Zero 8 BLTZAL Branch on Less Than Zero and Link 9 BNE Branch on Not Equal 10 J Jump 11 JAL Jump and Link 12 JALR Jump and Link Register 13 JALR.HB Jump and Link Register with Hazard Barrier Release 2 Only 14 JR Jump Register 15 JR.HB Jump Register with Hazard Barrier Release 2 Only CPU Instruction Control Instruction \u00b6 Mnemonic Instruction Misc. 0 EHB Execution Hazard Barrier Release 2 Only 1 NOP No Operation 2 SSNOP Superscalar No Operation CPU Load, Store, and Memory Control Instructions \u00b6 Mnemonic Instruction Misc. 0 LB Load Byte 1 LBU Load Byte Unsigned 2 LH Load Halfword 3 LHU Load Halfword Unsigned 4 LL Load Linked Word 5 LW Load Word 6 LWL Load Word Left 7 LWR Load Word Right 8 PREF Prefetch 9 SB Store Byte 10 SC Store Conditional Word 11 SH Store Halfword 12 SW Store Word 13 SWL Store Word Left 14 SWR Store Word Right 15 SYNC Synchronize Shared Memory 16 SYNCI Synchronize Caches to Make Instruction Writes Effective Release 2 Only CPU Logical Instructions \u00b6 Mnemonic Instruction 0 AND And 1 ANDI And Immediate 2 LUI Load Upper Immediate 3 NOR Not Or 4 OR Or 5 ORI Or Immediate 6 XOR Exclusive Or 7 XORI Exclusive Or Immediate CPU InsertExtract Instructions \u00b6 Mnemonic Instruction Misc. 0 EXT Extract Bit Field Release 2 Only 1 INS Insert Bit Field Release 2 Only 2 WSBH Word Swap Bytes Within Halfwords Release 2 Only CPU Move Instructions \u00b6 Mnemonic Instruction Misc. 0 MFHI Move From HI Register 1 MFLO Move From LO Register 2 MOVF Move Conditional on Floating Point False 3 MOVN Move Conditional on Not Zero 4 MOVT Move Conditional on Floating Point True 5 MOVZ Move Conditional on Zero 6 MTHI Move To HI Register 7 MTLO Move To LO Register 8 RDHWR Read Hardware Register Release 2 Only CPU Shift Instructions \u00b6 Mnemonic Instruction Misc. 0 ROTR Rotate Word Right Release 2 Only 1 ROTRV Rotate Word Right Variable Release 2 Only 2 SLL Shift Word Left Logical 3 SLLV Shift Word Left Logical Variable 4 SRA Shift Word Right Arithmetic 5 SRAV Shift Word Right Arithmetic Variable 6 SRL Shift Word Right Logical 7 SRLV Shift Word Right Logical Variable CPU Trap Instructions \u00b6 Mnemonic Instruction Misc. 0 BREAK Breakpoint 1 SYSCALL System Call 2 TEQ Trap if Equal 3 TEQI Trap if Equal Immediate 4 TGE Trap if Greater or Equal 5 TGEI Trap if Greater of Equal Immediate 6 TGEIU Trap if Greater or Equal Immediate Unsigned 7 TGEU Trap if Greater or Equal Unsigned 8 TLT Trap if Less Than 9 TLTI Trap if Less Than Immediate 10 TLTIU Trap if Less Than Immediate Unsigned 11 TLTU Trap if Less Than Unsigned 12 TNE Trap if Not Equal 13 TNEI Trap if Not Equal Immediate Obsolete CPU Branch Instructions \u00b6 Mnemonic Instruction 0 BEQL Branch on Equal Likely 1 BGEZALL Branch on Greater Than or Equal to Zero and Link Likely 2 BGEZL Branch on Greater Than or Equal to Zero Likely 3 BGTZL Branch on Greater Than Zero Likely 4 BLEZL Branch on Less Than or Equal to Zero Likely 5 BLTZALL Branch on Less Than Zero and Link Likely 6 BLTZL Branch on Less Than Zero Likely 7 BNEL Branch on Not Equal Likely FPU Arithmetic Instruction \u00b6 Mnemonic Instruction 0 ABS.fmt Floating Point Absolute Value 1 ADD.fmt Floating Point Add 2 DIV.fmt Floating Point Divide 3 MADD.fmt Floating Point Multiply Add 4 MSUB.fmt Floating Point Multiply Subtract 5 MUL.fmt Floating Point Multiply 6 NEG.fmt Floating Point Negate 7 NMADD.fmt Floating Point Negative Multiply Add 8 NMSUB.fmt Floating Point Negative Multiply Subtract 9 RECIP.fmt Reciprocal Approximation 10 RSQRT.fmt Reciprocal Square Root Approximation 11 SQRT.fmt Floating Point Square Root 12 SUB.fmt Floating Point Subtract FPU Branch Instructions \u00b6 Mnemonic Instruction 0 BC1F Branch on FP False 1 BC1T Branch on FP True 2 C.cond.fmt Floating Point Compare FPU Compare Instructions \u00b6 Mnemonic Instruction 0 C.cond.fmt Floating Point Compare FPU Convert Instructions \u00b6 Mnemonic Instruction Misc. 0 ALNV.PS Floating Point Align Variable 64-bit FPU Only 1 CEIL.L.fmt Floating Point Ceiling Convert to Long Fixed Point 64-bit FPU Only 2 CEIL.W.fmt Floating Point Ceiling Convert to Word Fixed Point 3 CVT.D.fmt Floating Point Convert to Double Floating Point 4 CVT.L.fmt Floating Point Convert to Long Fixed Point 64-bit FPU Only 5 CVT.PS.S Floating Point Convert Pair to Paired Single 64-bit FPU Only 6 CVT.S.PL Floating Point Convert Pair Lower to Single Floating Point 64-bit FPU Only 7 CVT.S.PU Floating Point Convert Pair Upper to Single Floating Point 64-bit FPU Only 8 CVT.S.fmt Floating Point Convert to Single Floating Point 9 CVT.W.fmt Floating Point Convert to Word Fixed Point 10 FLOOR.L.fmt Floating Point Floor Convert to Long Fixed Point 64-bit FPU Only 11 FLOOR.W.fmt Floating Point Floor Convert to Word Fixed Point 12 PLL.PS Pair Lower Lower 64-bit FPU Only 13 PLU.PS Pair Lower Upper 64-bit FPU Only 14 PUL.PS Pair Upper Lower 64-bit FPU Only 15 PUU.PS Pair Upper Upper 64-bit FPU Only 16 ROUND.L.fmt Floating Point Round to Long Fixed Point 64-bit FPU Only 17 ROUND.W.fmt Floating Point Round to Word Fixed Point 18 TRUNC.L.fmt Floating Point Truncate to Long Fixed Point 64-bit FPU Only 19 TRUNC.W.fmt Floating Point Truncate to Word Fixed Point FPU Load, Store, and Memory Control Instructions \u00b6 Mnemonic Instruction Misc. 0 LDC1 Load Doubleword to Floating Point 1 LDXC1 Load Doubleword Indexed to Floating Point 64-bit FPU Only 2 LUXC1 Load Doubleword Indexed Unaligned to Floating Point 64-bit FPU Only 3 LWC1 Load Word to Floating Point 4 LWXC1 Load Word Indexed to Floating Point 64-bit FPU Only 5 PREFX Prefetch Indexed 6 SDC1 Store Doubleword from Floating Point 7 SDXC1 Store Doubleword Indexed from Floating Point 64-bit FPU Only 8 SUXC1 Store Doubleword Indexed Unaligned from Floating Point 64-bit FPU Only 9 SWC1 Store Word from Floating Point 10 SWXC1 Store Word Indexed from Floating Point 64-bit FPU Only FPU Move Instructions \u00b6 Mnemonic Instruction Misc. 0 CFC1 Move Control Word from Floating Point 1 CTC1 Move Control Word to Floating Point 2 MFC1 Move Word from Floating Point 3 MFHC1 Move Word from High Half of Floating Point Register Release 2 Only 4 MOV.fmt Floating Point Move 5 MOVF.fmt Floating Point Move Conditional on Floating Point False 6 MOVN.fmt Floating Point Move Conditional on Not Zero 7 MOVT.fmt Floating Point Move Conditional on Floating Point True 8 MOVZ.fmt Floating Point Move Conditional on Zero 9 MTC1 Move Word to Floating Point 10 MTHC1 Move Word to High Half of Floating Point Register Release 2 Only Obsolete FPU Branch Instructions \u00b6 Mnemonic Instruction 0 BC1FL Branch on FP False Likely 1 BC1TL Branch on FP True Likely Coprocessor Branch Instructions \u00b6 Mnemonic Instruction 0 BC2F Branch on COP2 False 1 BC2T Branch on COP2 True Coprocessor Execute Instructions \u00b6 Mnemonic Instruction 0 COP2 Coprocessor Operation to Coprocessor 2 Coprocessor Load and Store Instructions \u00b6 Mnemonic Instruction 0 LDC2 Load Doubleword to Coprocessor 2 1 LWC2 Load Word to Coprocessor 2 2 SDC2 Store Doubleword from Coprocessor 2 3 SWC2 Store Word from Coprocessor 2 Coprocessor Move Instructions \u00b6 Mnemonic Instruction Misc. 0 CFC2 Move Control Word from Coprocessor 2 1 CTC2 Move Control Word to Coprocessor 2 2 MFC2 Move Word from Coprocessor 2 3 MFHC2 Move Word from High Half of Coprocessor 2 Register Release 2 Only 4 MTC2 Move Word to Coprocessor 2 5 MTHC2 Move Word to High Half of Coprocessor 2 Register Release 2 Only Obsolete Coprocessor Branch Instructions \u00b6 Mnemonic Instruction 0 BC2FL Branch on COP2 False Likely 1 BC2TL Branch on COP2 True Likely Privileged Instructions \u00b6 Mnemonic Instruction Misc. 0 CACHE Perform Cache Operation 1 DI Disable Interrupts Release 2 Only 2 EI Enable Interrupts Release 2 Only 3 ERET Exception Return 4 MFC0 Move from Coprocessor 0 5 MTC0 Move to Coprocessor 0 6 RDPGPR Read GPR from Previous Shadow Set Release 2 Only 7 TLBP Probe TLB for Matching Entry 8 TLBR Read Indexed TLB Entry 9 TLBWI Write Indexed TLB Entry 10 TLBWR Write Random TLB Entry 11 WAIT Enter Standby Mode 12 WRPGPR Write GPR to Previous Shadow Set Release 2 Only EJTAG Instructions \u00b6 Mnemonic Instruction 0 DERET Debug Exception Return 1 SDBBP Software Debug Breakpoint","title":"MIPs ISA Release 2"},{"location":"DS/Full_ISA/ISA/#mips-isa-release-2","text":"All 199 instructions from MIPs ISA Release 2 are summarized below. In this class, we implement only about 7 of them. The full MIPS ISA reference documents are listed below. Volume Volume I: Introduction to the MIPS32 Architecture Volume II: The MIPS32 Instruction Set Volume III: The MIPS32 Privileged Resource Architecture","title":"MIPs ISA Release 2"},{"location":"DS/Full_ISA/ISA/#cpu-arithmetic-instructions","text":"Mnemonic Instruction Misc. 0 ADD Add Word 1 ADDI Add Immediate Word 2 ADDIU Add Immediate Unsigned Word 3 ADDU Add Unsigned Word 4 CLO Count Leading Ones in Word 5 CLZ Count Leading Zeros in Word 6 DIV Divide Word 7 DIVU Divide Unsigned Word 8 MADD Multiply and Add Word to Hi, Lo 9 MADDU Multiply and Add Unsigned Word to Hi, Lo 10 MSUB Multiply and Subtract Word to Hi, Lo 11 MSUBU Multiply and Subtract Unsigned Word to Hi, Lo 12 MUL Multiply Word to GPR 13 MULT Multiply Word 14 MULTU Multiply Unsigned Word 15 SEB Sign-Extend Byte Release 2 Only 16 SEH Sign-Extend Halftword Release 2 Only 17 SLT Set on Less Than 18 SLTI Set on Less Than Immediate 19 SLTIU Set on Less Than Immediate Unsigned 20 SLTU Set on Less Than Unsigned 21 SUB Subtract Word 22 SUBU Subtract Unsigned Word","title":"CPU Arithmetic Instructions"},{"location":"DS/Full_ISA/ISA/#cpu-branch-and-jump-instructions","text":"Mnemonic Instruction Misc. 0 B Unconditional Branch 1 BAL Branch and Link 2 BEQ Branch on Equal 3 BGEZ Branch on Greater Than or Equal to Zero 4 BGEZAL Branch on Greater Than or Equal to Zero and Link 5 BGTZ Branch on Greater Than Zero 6 BLEZ Branch on Less Than or Equal to Zero 7 BLTZ Branch on Less Than Zero 8 BLTZAL Branch on Less Than Zero and Link 9 BNE Branch on Not Equal 10 J Jump 11 JAL Jump and Link 12 JALR Jump and Link Register 13 JALR.HB Jump and Link Register with Hazard Barrier Release 2 Only 14 JR Jump Register 15 JR.HB Jump Register with Hazard Barrier Release 2 Only","title":"CPU Branch and Jump Instructions"},{"location":"DS/Full_ISA/ISA/#cpu-instruction-control-instruction","text":"Mnemonic Instruction Misc. 0 EHB Execution Hazard Barrier Release 2 Only 1 NOP No Operation 2 SSNOP Superscalar No Operation","title":"CPU Instruction Control Instruction"},{"location":"DS/Full_ISA/ISA/#cpu-load-store-and-memory-control-instructions","text":"Mnemonic Instruction Misc. 0 LB Load Byte 1 LBU Load Byte Unsigned 2 LH Load Halfword 3 LHU Load Halfword Unsigned 4 LL Load Linked Word 5 LW Load Word 6 LWL Load Word Left 7 LWR Load Word Right 8 PREF Prefetch 9 SB Store Byte 10 SC Store Conditional Word 11 SH Store Halfword 12 SW Store Word 13 SWL Store Word Left 14 SWR Store Word Right 15 SYNC Synchronize Shared Memory 16 SYNCI Synchronize Caches to Make Instruction Writes Effective Release 2 Only","title":"CPU Load, Store, and Memory Control Instructions"},{"location":"DS/Full_ISA/ISA/#cpu-logical-instructions","text":"Mnemonic Instruction 0 AND And 1 ANDI And Immediate 2 LUI Load Upper Immediate 3 NOR Not Or 4 OR Or 5 ORI Or Immediate 6 XOR Exclusive Or 7 XORI Exclusive Or Immediate","title":"CPU Logical Instructions"},{"location":"DS/Full_ISA/ISA/#cpu-insertextract-instructions","text":"Mnemonic Instruction Misc. 0 EXT Extract Bit Field Release 2 Only 1 INS Insert Bit Field Release 2 Only 2 WSBH Word Swap Bytes Within Halfwords Release 2 Only","title":"CPU InsertExtract Instructions"},{"location":"DS/Full_ISA/ISA/#cpu-move-instructions","text":"Mnemonic Instruction Misc. 0 MFHI Move From HI Register 1 MFLO Move From LO Register 2 MOVF Move Conditional on Floating Point False 3 MOVN Move Conditional on Not Zero 4 MOVT Move Conditional on Floating Point True 5 MOVZ Move Conditional on Zero 6 MTHI Move To HI Register 7 MTLO Move To LO Register 8 RDHWR Read Hardware Register Release 2 Only","title":"CPU Move Instructions"},{"location":"DS/Full_ISA/ISA/#cpu-shift-instructions","text":"Mnemonic Instruction Misc. 0 ROTR Rotate Word Right Release 2 Only 1 ROTRV Rotate Word Right Variable Release 2 Only 2 SLL Shift Word Left Logical 3 SLLV Shift Word Left Logical Variable 4 SRA Shift Word Right Arithmetic 5 SRAV Shift Word Right Arithmetic Variable 6 SRL Shift Word Right Logical 7 SRLV Shift Word Right Logical Variable","title":"CPU Shift Instructions"},{"location":"DS/Full_ISA/ISA/#cpu-trap-instructions","text":"Mnemonic Instruction Misc. 0 BREAK Breakpoint 1 SYSCALL System Call 2 TEQ Trap if Equal 3 TEQI Trap if Equal Immediate 4 TGE Trap if Greater or Equal 5 TGEI Trap if Greater of Equal Immediate 6 TGEIU Trap if Greater or Equal Immediate Unsigned 7 TGEU Trap if Greater or Equal Unsigned 8 TLT Trap if Less Than 9 TLTI Trap if Less Than Immediate 10 TLTIU Trap if Less Than Immediate Unsigned 11 TLTU Trap if Less Than Unsigned 12 TNE Trap if Not Equal 13 TNEI Trap if Not Equal Immediate","title":"CPU Trap Instructions"},{"location":"DS/Full_ISA/ISA/#obsolete-cpu-branch-instructions","text":"Mnemonic Instruction 0 BEQL Branch on Equal Likely 1 BGEZALL Branch on Greater Than or Equal to Zero and Link Likely 2 BGEZL Branch on Greater Than or Equal to Zero Likely 3 BGTZL Branch on Greater Than Zero Likely 4 BLEZL Branch on Less Than or Equal to Zero Likely 5 BLTZALL Branch on Less Than Zero and Link Likely 6 BLTZL Branch on Less Than Zero Likely 7 BNEL Branch on Not Equal Likely","title":"Obsolete CPU Branch Instructions"},{"location":"DS/Full_ISA/ISA/#fpu-arithmetic-instruction","text":"Mnemonic Instruction 0 ABS.fmt Floating Point Absolute Value 1 ADD.fmt Floating Point Add 2 DIV.fmt Floating Point Divide 3 MADD.fmt Floating Point Multiply Add 4 MSUB.fmt Floating Point Multiply Subtract 5 MUL.fmt Floating Point Multiply 6 NEG.fmt Floating Point Negate 7 NMADD.fmt Floating Point Negative Multiply Add 8 NMSUB.fmt Floating Point Negative Multiply Subtract 9 RECIP.fmt Reciprocal Approximation 10 RSQRT.fmt Reciprocal Square Root Approximation 11 SQRT.fmt Floating Point Square Root 12 SUB.fmt Floating Point Subtract","title":"FPU Arithmetic Instruction"},{"location":"DS/Full_ISA/ISA/#fpu-branch-instructions","text":"Mnemonic Instruction 0 BC1F Branch on FP False 1 BC1T Branch on FP True 2 C.cond.fmt Floating Point Compare","title":"FPU Branch Instructions"},{"location":"DS/Full_ISA/ISA/#fpu-compare-instructions","text":"Mnemonic Instruction 0 C.cond.fmt Floating Point Compare","title":"FPU Compare Instructions"},{"location":"DS/Full_ISA/ISA/#fpu-convert-instructions","text":"Mnemonic Instruction Misc. 0 ALNV.PS Floating Point Align Variable 64-bit FPU Only 1 CEIL.L.fmt Floating Point Ceiling Convert to Long Fixed Point 64-bit FPU Only 2 CEIL.W.fmt Floating Point Ceiling Convert to Word Fixed Point 3 CVT.D.fmt Floating Point Convert to Double Floating Point 4 CVT.L.fmt Floating Point Convert to Long Fixed Point 64-bit FPU Only 5 CVT.PS.S Floating Point Convert Pair to Paired Single 64-bit FPU Only 6 CVT.S.PL Floating Point Convert Pair Lower to Single Floating Point 64-bit FPU Only 7 CVT.S.PU Floating Point Convert Pair Upper to Single Floating Point 64-bit FPU Only 8 CVT.S.fmt Floating Point Convert to Single Floating Point 9 CVT.W.fmt Floating Point Convert to Word Fixed Point 10 FLOOR.L.fmt Floating Point Floor Convert to Long Fixed Point 64-bit FPU Only 11 FLOOR.W.fmt Floating Point Floor Convert to Word Fixed Point 12 PLL.PS Pair Lower Lower 64-bit FPU Only 13 PLU.PS Pair Lower Upper 64-bit FPU Only 14 PUL.PS Pair Upper Lower 64-bit FPU Only 15 PUU.PS Pair Upper Upper 64-bit FPU Only 16 ROUND.L.fmt Floating Point Round to Long Fixed Point 64-bit FPU Only 17 ROUND.W.fmt Floating Point Round to Word Fixed Point 18 TRUNC.L.fmt Floating Point Truncate to Long Fixed Point 64-bit FPU Only 19 TRUNC.W.fmt Floating Point Truncate to Word Fixed Point","title":"FPU Convert Instructions"},{"location":"DS/Full_ISA/ISA/#fpu-load-store-and-memory-control-instructions","text":"Mnemonic Instruction Misc. 0 LDC1 Load Doubleword to Floating Point 1 LDXC1 Load Doubleword Indexed to Floating Point 64-bit FPU Only 2 LUXC1 Load Doubleword Indexed Unaligned to Floating Point 64-bit FPU Only 3 LWC1 Load Word to Floating Point 4 LWXC1 Load Word Indexed to Floating Point 64-bit FPU Only 5 PREFX Prefetch Indexed 6 SDC1 Store Doubleword from Floating Point 7 SDXC1 Store Doubleword Indexed from Floating Point 64-bit FPU Only 8 SUXC1 Store Doubleword Indexed Unaligned from Floating Point 64-bit FPU Only 9 SWC1 Store Word from Floating Point 10 SWXC1 Store Word Indexed from Floating Point 64-bit FPU Only","title":"FPU Load, Store, and Memory Control Instructions"},{"location":"DS/Full_ISA/ISA/#fpu-move-instructions","text":"Mnemonic Instruction Misc. 0 CFC1 Move Control Word from Floating Point 1 CTC1 Move Control Word to Floating Point 2 MFC1 Move Word from Floating Point 3 MFHC1 Move Word from High Half of Floating Point Register Release 2 Only 4 MOV.fmt Floating Point Move 5 MOVF.fmt Floating Point Move Conditional on Floating Point False 6 MOVN.fmt Floating Point Move Conditional on Not Zero 7 MOVT.fmt Floating Point Move Conditional on Floating Point True 8 MOVZ.fmt Floating Point Move Conditional on Zero 9 MTC1 Move Word to Floating Point 10 MTHC1 Move Word to High Half of Floating Point Register Release 2 Only","title":"FPU Move Instructions"},{"location":"DS/Full_ISA/ISA/#obsolete-fpu-branch-instructions","text":"Mnemonic Instruction 0 BC1FL Branch on FP False Likely 1 BC1TL Branch on FP True Likely","title":"Obsolete FPU Branch Instructions"},{"location":"DS/Full_ISA/ISA/#coprocessor-branch-instructions","text":"Mnemonic Instruction 0 BC2F Branch on COP2 False 1 BC2T Branch on COP2 True","title":"Coprocessor Branch Instructions"},{"location":"DS/Full_ISA/ISA/#coprocessor-execute-instructions","text":"Mnemonic Instruction 0 COP2 Coprocessor Operation to Coprocessor 2","title":"Coprocessor Execute Instructions"},{"location":"DS/Full_ISA/ISA/#coprocessor-load-and-store-instructions","text":"Mnemonic Instruction 0 LDC2 Load Doubleword to Coprocessor 2 1 LWC2 Load Word to Coprocessor 2 2 SDC2 Store Doubleword from Coprocessor 2 3 SWC2 Store Word from Coprocessor 2","title":"Coprocessor Load and Store Instructions"},{"location":"DS/Full_ISA/ISA/#coprocessor-move-instructions","text":"Mnemonic Instruction Misc. 0 CFC2 Move Control Word from Coprocessor 2 1 CTC2 Move Control Word to Coprocessor 2 2 MFC2 Move Word from Coprocessor 2 3 MFHC2 Move Word from High Half of Coprocessor 2 Register Release 2 Only 4 MTC2 Move Word to Coprocessor 2 5 MTHC2 Move Word to High Half of Coprocessor 2 Register Release 2 Only","title":"Coprocessor Move Instructions"},{"location":"DS/Full_ISA/ISA/#obsolete-coprocessor-branch-instructions","text":"Mnemonic Instruction 0 BC2FL Branch on COP2 False Likely 1 BC2TL Branch on COP2 True Likely","title":"Obsolete Coprocessor Branch Instructions"},{"location":"DS/Full_ISA/ISA/#privileged-instructions","text":"Mnemonic Instruction Misc. 0 CACHE Perform Cache Operation 1 DI Disable Interrupts Release 2 Only 2 EI Enable Interrupts Release 2 Only 3 ERET Exception Return 4 MFC0 Move from Coprocessor 0 5 MTC0 Move to Coprocessor 0 6 RDPGPR Read GPR from Previous Shadow Set Release 2 Only 7 TLBP Probe TLB for Matching Entry 8 TLBR Read Indexed TLB Entry 9 TLBWI Write Indexed TLB Entry 10 TLBWR Write Random TLB Entry 11 WAIT Enter Standby Mode 12 WRPGPR Write GPR to Previous Shadow Set Release 2 Only","title":"Privileged Instructions"},{"location":"DS/Full_ISA/ISA/#ejtag-instructions","text":"Mnemonic Instruction 0 DERET Debug Exception Return 1 SDBBP Software Debug Breakpoint","title":"EJTAG Instructions"},{"location":"DS/Full_ISA/prologue/","text":"MIPs ISA Release 2 \u00b6 All 199 instructions from MIPs ISA Release 2 are summarized below. In this class, we implement only about 7 of them. The full MIPS ISA reference documents are listed below. Volume Volume I: Introduction to the MIPS32 Architecture Volume II: The MIPS32 Instruction Set Volume III: The MIPS32 Privileged Resource Architecture","title":"MIPs ISA Release 2"},{"location":"DS/Full_ISA/prologue/#mips-isa-release-2","text":"All 199 instructions from MIPs ISA Release 2 are summarized below. In this class, we implement only about 7 of them. The full MIPS ISA reference documents are listed below. Volume Volume I: Introduction to the MIPS32 Architecture Volume II: The MIPS32 Instruction Set Volume III: The MIPS32 Privileged Resource Architecture","title":"MIPs ISA Release 2"},{"location":"ECE/VCD/vcd/","text":"When debugging hardware that you've described in RTL, its often helpful to be able to see a waveform representation of what its doing. One of the most common waveform viewers is GTKWave. Scansion is also a really good waveform viewer(but its only available for Mac). I prefer to use Scansion when on my Mac because it supports Mac gestures as well as HiDPI displays. Installing GTKWave \u00b6 Ubuntu \u00b6 apt install gtkwave By default, you cannot view the display in bash for windows. To remedy this, do the following in bash for windows : export DISPLAY=:0 You'll also need to download, install, and open Xming . Once you open Xming, it should start a process in the backgroung. Now, go ahead and type gtkwave . A new window should open like the one in the image below. MacOS \u00b6 Download the GTKWave app for MacOS: Once the app has downloaded, drag the app from your Downloads folder to your Aplications folder. Viewing a Waveform with GTKWave \u00b6 To open a waveform with GTKWave on Linux, run gtkwave /path/to/wave.vcd . On Mac, if you're using GTKWave, you can open the GTKWave application, and then use file \\rightarrow \\rightarrow open new window to access the file. Download this VCD and complete the following steps. Drag some signals from pane 2 to pane 3 as shown below. You can also import all signals at once as shown below. GTKWave tends to zoom all the way in on signals at first. You must click the icon below multiple time to zoom out properly. Using Scansion instead of GTKWave on Mac \u00b6 You can download Scansion from here . Drag it to the /Applications folder. Once you've opened Scansion, you can drag a VCD file from finder onto the Scansion icon as shown below. A new Scansion window should show up. You can view signals by dragging them from 2 to 3 as shown below. You can also view all the signals at once for a selected module from pane 1 by clicking the browse button.","title":"Using GTKWave or Scansion"},{"location":"ECE/VCD/vcd/#installing-gtkwave","text":"","title":"Installing GTKWave"},{"location":"ECE/VCD/vcd/#ubuntu","text":"apt install gtkwave By default, you cannot view the display in bash for windows. To remedy this, do the following in bash for windows : export DISPLAY=:0 You'll also need to download, install, and open Xming . Once you open Xming, it should start a process in the backgroung. Now, go ahead and type gtkwave . A new window should open like the one in the image below.","title":"Ubuntu"},{"location":"ECE/VCD/vcd/#macos","text":"Download the GTKWave app for MacOS: Once the app has downloaded, drag the app from your Downloads folder to your Aplications folder.","title":"MacOS"},{"location":"ECE/VCD/vcd/#viewing-a-waveform-with-gtkwave","text":"To open a waveform with GTKWave on Linux, run gtkwave /path/to/wave.vcd . On Mac, if you're using GTKWave, you can open the GTKWave application, and then use file \\rightarrow \\rightarrow open new window to access the file. Download this VCD and complete the following steps. Drag some signals from pane 2 to pane 3 as shown below. You can also import all signals at once as shown below. GTKWave tends to zoom all the way in on signals at first. You must click the icon below multiple time to zoom out properly.","title":"Viewing a Waveform with GTKWave"},{"location":"ECE/VCD/vcd/#using-scansion-instead-of-gtkwave-on-mac","text":"You can download Scansion from here . Drag it to the /Applications folder. Once you've opened Scansion, you can drag a VCD file from finder onto the Scansion icon as shown below. A new Scansion window should show up. You can view signals by dragging them from 2 to 3 as shown below. You can also view all the signals at once for a selected module from pane 1 by clicking the browse button.","title":"Using Scansion instead of GTKWave on Mac"},{"location":"ECE/brew/brew/","text":"Since some of the tools in this class such as yosys and nMigen are bleeding edge, we use the Homebrew(Mac)/Linuxbrew package manager which makes accessing the latest build easy. MacOS \u00b6 Installing brew on MacOS is easy: /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\" Ubuntu \u00b6 Installing brew on Ubuntu is a little more involved. sudo apt-get install build-essential curl file git sh -c \"$(curl -fsSL https://raw.githubusercontent.com/Linuxbrew/install/master/install.sh)\" echo eval $(/home/linuxbrew/.linuxbrew/bin/brew shellenv) >>~/.bashrc echo export LD_LIBRARY_PATH=/lib:/usr/lib:/usr/local/lib:/home/linuxbrew/.linuxbrew/lib >>~/.bashrc Then restart your terminal. Installing Tools \u00b6 I maintain a brew RTL tools tap which you can use in this class. Go ahead and tap it. brew tap bracketmaster/rtl","title":"Installing Homebrew/LinuxBrew"},{"location":"ECE/brew/brew/#macos","text":"Installing brew on MacOS is easy: /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\"","title":"MacOS"},{"location":"ECE/brew/brew/#ubuntu","text":"Installing brew on Ubuntu is a little more involved. sudo apt-get install build-essential curl file git sh -c \"$(curl -fsSL https://raw.githubusercontent.com/Linuxbrew/install/master/install.sh)\" echo eval $(/home/linuxbrew/.linuxbrew/bin/brew shellenv) >>~/.bashrc echo export LD_LIBRARY_PATH=/lib:/usr/lib:/usr/local/lib:/home/linuxbrew/.linuxbrew/lib >>~/.bashrc Then restart your terminal.","title":"Ubuntu"},{"location":"ECE/brew/brew/#installing-tools","text":"I maintain a brew RTL tools tap which you can use in this class. Go ahead and tap it. brew tap bracketmaster/rtl","title":"Installing Tools"},{"location":"ECE/cocotb/cocotb/","text":"What is Cocotb ? \u00b6 Cocotb is a Python simulator frontend. It supports the following simulators(bold are FOSS): Icarus Verilog Verilator GHDL Synopsys VCS Aldec Riviera-PRO Mentor Questa Mentor ModelSim Cadence Incisive Cadence Xcelium Tachyon DA CVC Dependencies \u00b6 First make sure you have brew installed. brew install python3 icarus-verilog Setting Up a Python Virtual Environment \u00b6 Cocotb is shipped as a Python package. Python comes with a package manager called pip . For python2, pip is usually aliased to pip , and for python3, pip is aliased to pip3 . Since there are often many versions of one package available in pypi(the repository store for pip), it is usually a good idea to use a python virtual environment to isolate conflicts between packages. #install virtual environment from pypi pip3 install virtualenv mkdir ~/.virtualenvs cd ~/.virtualenvs #create a virtual environment to be used for #cocotb python3 -m venv rtl #activate virtual environment source ~/.virtualenvs/rtl/bin/activate #install cocotb pip3 install --upgrade git+git://github.com/cocotb/cocotb@f87361c Using Cocotb \u00b6 From now on, anytime you wish to use Cocotb, simply do: source ~/.virtualenvs/rtl/bin/activate For an example of using Cocotb, see labs: Gentle Intro","title":"Installing Cocotb and Icarus Verilog"},{"location":"ECE/cocotb/cocotb/#what-is-cocotb","text":"Cocotb is a Python simulator frontend. It supports the following simulators(bold are FOSS): Icarus Verilog Verilator GHDL Synopsys VCS Aldec Riviera-PRO Mentor Questa Mentor ModelSim Cadence Incisive Cadence Xcelium Tachyon DA CVC","title":"What is Cocotb?"},{"location":"ECE/cocotb/cocotb/#dependencies","text":"First make sure you have brew installed. brew install python3 icarus-verilog","title":"Dependencies"},{"location":"ECE/cocotb/cocotb/#setting-up-a-python-virtual-environment","text":"Cocotb is shipped as a Python package. Python comes with a package manager called pip . For python2, pip is usually aliased to pip , and for python3, pip is aliased to pip3 . Since there are often many versions of one package available in pypi(the repository store for pip), it is usually a good idea to use a python virtual environment to isolate conflicts between packages. #install virtual environment from pypi pip3 install virtualenv mkdir ~/.virtualenvs cd ~/.virtualenvs #create a virtual environment to be used for #cocotb python3 -m venv rtl #activate virtual environment source ~/.virtualenvs/rtl/bin/activate #install cocotb pip3 install --upgrade git+git://github.com/cocotb/cocotb@f87361c","title":"Setting Up a Python Virtual Environment"},{"location":"ECE/cocotb/cocotb/#using-cocotb","text":"From now on, anytime you wish to use Cocotb, simply do: source ~/.virtualenvs/rtl/bin/activate For an example of using Cocotb, see labs: Gentle Intro","title":"Using Cocotb"},{"location":"ECE/gcc-mips/GCC_MIPS/","text":"Background \u00b6 In the early part of this class, we'll be designing a MIPS processor. To test, our processor, we need it to execute instructions. While it is possible to assemble instructions from opcodes by hand, and type them up into a memory array in Verilog manually, there are already tools available to do this. What Compilers Do \u00b6 A compiler will take a source language such as C and convert it into some intermediate language. This intermediate language is usually one step above assembly. The compiler, in another pass will then take the intermediate language and lower it into assembly internally. After this, the compiler will assemble or encode the instructions into opcodes. Lastly, the compiler will often emit one or more object files. These different stages are usually referred to as compiler passes. Examples of compilers that behave like this are GNU C Compiler and Clang+LLVM compiler toolchain. Usually, the passes look like this: Compiler starts by lexing source Parser generates an abstract syntax tree Compiler runs AST optimizations Compiler emits intermediate Compiler runs more optimization passes Compiler generates assembly files with symbols You can usually pass flags to a compiler to stop here. For example, to get assembly out of gcc, you can pass the -S flag. gcc -S foo.c Also, symbols are references to names of functions, or links to locations of data that will be translated into addresses once the linker resolves symbols from object files Translate the assembly to object files. Object files have mostly assembled opcodes, but still have unresolved symbols and possibly addresses. Often times, people will have the compiler stop here using the -o flag. For example: gcc foo.c -o foo.o gcc bar.c -o bar.o ld foo.o bar.o -o foobar The linker is invoked to link the object files together. The Linker \u00b6 The linker uses a linker script that tells it how to place certain parts of the generated executable into memory. For example, the instructions at the start of the program may need to be placed at address 0x4000. Usually, the linker uses a default linker script that is specific to the operating system. Also, many processors use interrupts. For an embedded processor, the interrupt routines have to be placed at a specific address in memory. In a general computer processor with an operating system, usually the kernel places interrupt routines at the right spots in memory during boot-up. For this class \u00b6 In this class, since we won't be designing a processor that is completely capable of supporting C library routines from libstdc , we will be mainly working with assembly files. For example, printf won't work on our processor - we're only focusing on 15 out of 72 instructions. Thus, we don't need a full compiler toolchain, we just need the assembler and linker. GCC Binutils provides a MIPs linker and assembler. Install Binutils \u00b6 First make sure that you have install brew Then do: brew install bracketmaster/rtl/binutils-mips-elf If you can do: mips-elf-as --help Usage: mips-elf-as [option...] [asmfile...] Options: -a[sub-option...] turn on listings Sub-options [default hls]: c omit false conditionals ... Then you're good to go.","title":"Installing The GCC-MIPS Compiler"},{"location":"ECE/gcc-mips/GCC_MIPS/#background","text":"In the early part of this class, we'll be designing a MIPS processor. To test, our processor, we need it to execute instructions. While it is possible to assemble instructions from opcodes by hand, and type them up into a memory array in Verilog manually, there are already tools available to do this.","title":"Background"},{"location":"ECE/gcc-mips/GCC_MIPS/#what-compilers-do","text":"A compiler will take a source language such as C and convert it into some intermediate language. This intermediate language is usually one step above assembly. The compiler, in another pass will then take the intermediate language and lower it into assembly internally. After this, the compiler will assemble or encode the instructions into opcodes. Lastly, the compiler will often emit one or more object files. These different stages are usually referred to as compiler passes. Examples of compilers that behave like this are GNU C Compiler and Clang+LLVM compiler toolchain. Usually, the passes look like this: Compiler starts by lexing source Parser generates an abstract syntax tree Compiler runs AST optimizations Compiler emits intermediate Compiler runs more optimization passes Compiler generates assembly files with symbols You can usually pass flags to a compiler to stop here. For example, to get assembly out of gcc, you can pass the -S flag. gcc -S foo.c Also, symbols are references to names of functions, or links to locations of data that will be translated into addresses once the linker resolves symbols from object files Translate the assembly to object files. Object files have mostly assembled opcodes, but still have unresolved symbols and possibly addresses. Often times, people will have the compiler stop here using the -o flag. For example: gcc foo.c -o foo.o gcc bar.c -o bar.o ld foo.o bar.o -o foobar The linker is invoked to link the object files together.","title":"What Compilers Do"},{"location":"ECE/gcc-mips/GCC_MIPS/#the-linker","text":"The linker uses a linker script that tells it how to place certain parts of the generated executable into memory. For example, the instructions at the start of the program may need to be placed at address 0x4000. Usually, the linker uses a default linker script that is specific to the operating system. Also, many processors use interrupts. For an embedded processor, the interrupt routines have to be placed at a specific address in memory. In a general computer processor with an operating system, usually the kernel places interrupt routines at the right spots in memory during boot-up.","title":"The Linker"},{"location":"ECE/gcc-mips/GCC_MIPS/#for-this-class","text":"In this class, since we won't be designing a processor that is completely capable of supporting C library routines from libstdc , we will be mainly working with assembly files. For example, printf won't work on our processor - we're only focusing on 15 out of 72 instructions. Thus, we don't need a full compiler toolchain, we just need the assembler and linker. GCC Binutils provides a MIPs linker and assembler.","title":"For this class"},{"location":"ECE/gcc-mips/GCC_MIPS/#install-binutils","text":"First make sure that you have install brew Then do: brew install bracketmaster/rtl/binutils-mips-elf If you can do: mips-elf-as --help Usage: mips-elf-as [option...] [asmfile...] Options: -a[sub-option...] turn on listings Sub-options [default hls]: c omit false conditionals ... Then you're good to go.","title":"Install Binutils"},{"location":"ECE/gcc-mips/gcc-from-source/","text":"Copied under CC BY-SA 3.0 from: The Airport Wiki This guide will outline the steps necessary to build a cross compilation of GCC for a target architecture of MIPS on a OS X host machine. GCC (The GNU Compiler Collection) is an open source compiler used for compiling computer code written in high level languages such as C and C++. The compiler is need to convert the high level / human readable language code into machine level / assembly language code. As of 2014, Apple is natively shipping the LLVM compiler with OS X (10.9) / Mavericks. I was unable to compile binutils for a target architecture of MIPS using the native LLVM compiler provided by Apple. An alternative I chose was to install GCC (4.8.2) using the Homebrew package management system. In order to install GCC via Homebrew, Homebrew must be installed on the host system first. (duh) The steps for installing homebrew can be found at brew.sh Alright, so your still reading, so that probably means you have Homebrew installed on your system, your just bored, or your reading just for the sake of learning something new. In that case, lets continue. In your favorite OS X terminal application run the following commands to get GCC installed via Homebrew. $ brew tap homebrew/versions $ brew install gcc48 Once GCC 4.8.x is installed the next step is to download the required packages to build a cross compile of GCC. From what I have read on the internet, in order to build a GCC toolchain the binutils package is required. So your probably gonna want to download it. Recommendation: I would download the following packages to the following location,* /opt/cross/src/ To download binutils run the following command in a shell. $ wget ftp://sourceware.org/pub/binutils/releases/binutils-2.24.tar.gz Note: If you don't have wget installed on your system you can install it with following command, $ brew install wget Next, download GCC source code, $ wget http://www.netgull.com/gcc/releases/gcc-4.8.2/gcc-4.8.2.tar.gz Note: This link may be broken in the future, so to get the latest version of GCC head on over to gcc.gnu.org Now extract the following newly downloaded packages with the following command, $ tar xzf binutils-2.24.tar.gz $ tar xzf gcc-4.8.2.tar.gz Next, download GCC dependencies / prerequisites, $ cd gcc-4.8.2 $ ./contrib/download_prerequisites $ cd .. Note: The GCC prerequisites are **mprf* , gmp , and mpc* Next, create the GCC binary folder / directory. $ mkdir mips-gcc Next, the following environment variables need to be set in order to use the homebrew version of GCC to cross compile GCC for the MIPS architecture. $ export CC=/usr/local/bin/gcc-4.8 $ export CXX=/usr/local/bin/g++-4.8 $ export CPP=/usr/local/bin/cpp-4.8 $ export LD=/usr/local/bin/gcc-4.8 $ export PREFIX=/opt/cross/gcc-mips $ export CFLAGS=-Wno-error=deprecated-declarations Note: To check if the environment variables are set correctly run the following command, $ echo $CC The above command should print something like, /usr/local/bin/gcc-4.8 Next, configure and build binutils. $ mkdir binutils-build $ cd binutils-build $ ../binutils-2.24/configure --target=mips-netbsd-elf --prefix=$PREFIX $ make all 2>&1 | tee make.log $ make install $ cd .. Note: binutils should now be installed in /opt/cross/gcc-mips/mips-gcc/bin The newly created binaries should be added to your path when building GCC, so run the following command, $ export PATH=${PREFIX}/bin:${PATH} Next, download, unpack newlib into /opt/cross/src , then make a directory called, newlib-build $ wget ftp://sourceware.org/pub/newlib/newlib-2.1.0.tar.gz $ tar xzf newlib-2.1.0.tar.gz $ mkdir newlib-build Now, it's time to configure and build a bootstrap cross compile of GCC :) $ mkdir gcc-build $ cd gcc-build $ ../gcc-4.8.2/configure --target=mips-netbsd-elf --prefix=$PREFIX --with-newlib --without-headers \\ --with-gnu-as --with-gnu-ld --disable-shared --enable-languages=c $ make all-gcc 2>&1 | tee make.log $ make install-gcc Now, at this point you might think you can compile a simple Hello MIPS program using the following code, /* Simple C program. */ #include<stdio.h> int main() { printf(\"Hello MIPS! \\n\"); return 0; } However it won't compile ...yet. Next, build the newlib C runtime library $ cd newlib-build $ ../newlib-2.1.0/configure --target=mips-netbsd-elf --prefix=$PREFIX $ make all 2>&1 | tee make.log $ make install Finally, it is time to build a complete cross compiler. $ cd gcc-build && rm -rf * $ ../gcc-4.8.2/configure --target=mips-netbsd-elf --prefix=$PREFIX --with-gnu-as \\ --with-gnu-ld --enable-languages=c,c++ --disable-multilib --with-newlib $ make all 2>&1 | tee make.log $ make install $ cd .. Now the simple Hello MIPS program can be compiled using the freshly built compiler. $ mips-elf-gcc -Tidt.ld hello.c -o hello If all goes well, you have just compiled Hello MIPS program with the above command and have a MIPS binary ready for testing. Thanks for reading, and happy building. See Also \u00b6 External Links \u00b6 apple.stackexchange.com thread on installing GCC via homebrew Cross compiling GCC for MIPS on Linux/Debian osdev.org GCC Cross Compiler article Compiling binutils on OS X Mavericks An Introduction to the GNU Compiler and Linker Toolchains - LinuxMIPS GCC Wiki FAQ Nacho's Cross Compile of GCC for MIPS GNU.org Installing GCC GNU.org Building a Cross Toolchain with GCC AVR/ARM Cross Toolchains for OS X GNU Host/Target specific installation notes","title":"Gcc from source"},{"location":"ECE/gcc-mips/gcc-from-source/#see-also","text":"","title":"See Also"},{"location":"ECE/gcc-mips/gcc-from-source/#external-links","text":"apple.stackexchange.com thread on installing GCC via homebrew Cross compiling GCC for MIPS on Linux/Debian osdev.org GCC Cross Compiler article Compiling binutils on OS X Mavericks An Introduction to the GNU Compiler and Linker Toolchains - LinuxMIPS GCC Wiki FAQ Nacho's Cross Compile of GCC for MIPS GNU.org Installing GCC GNU.org Building a Cross Toolchain with GCC AVR/ARM Cross Toolchains for OS X GNU Host/Target specific installation notes","title":"External Links"},{"location":"ECE/makefile/makefile_intro/","text":"Software is often built in stages. Suppose you had some source files that went through the following stages: compiler: source \\rightarrow \\rightarrow object linker: object \\rightarrow \\rightarrow executable The dependency build graph for a program called foobar might look like this: It is possible to write a single monolithic script that rebuilds every file at each stage every time you wish to rebuild the final executable. But if you only changed one file, this is an inefficient way to rebuild the executable. You should only rebuild the objects that depend on the files you changed, and then relink the new object and old objects together to build the executable. Makefiles allow you to build a dependency graph via rules that state the dependencies of generated files at various stages. Makefiles are executed with $make which consumes a makefile (usually named makefile or Makefile with no file extension), generates, and finally executes the dependency graph, only executing graph nodes with children that are younger than the parents. Format \u00b6 Makefiles specify the dependency graph using the following format. parent: child1 child2 ... childN #the command below tells the makefile how #to build the parents from children $command The above snippet is more commonly referred to as a makefile rule. You can learn more about makefile rules here . The makefile used in the intro assignment , has no rules in it directly. Instead, it imports rules from another file with the line: #included for cocotb include $(shell cocotb-config --makefiles)/Makefile.sim Cocotb uses a makefile because the simulators it supports convert RTL source files into executables using multiple stages. Thus, makefiles allow Cocotb to only rebuild changed files and their respective parents before it invokes simulation execution.","title":"Soft Intro to Makefiles"},{"location":"ECE/makefile/makefile_intro/#format","text":"Makefiles specify the dependency graph using the following format. parent: child1 child2 ... childN #the command below tells the makefile how #to build the parents from children $command The above snippet is more commonly referred to as a makefile rule. You can learn more about makefile rules here . The makefile used in the intro assignment , has no rules in it directly. Instead, it imports rules from another file with the line: #included for cocotb include $(shell cocotb-config --makefiles)/Makefile.sim Cocotb uses a makefile because the simulators it supports convert RTL source files into executables using multiple stages. Thus, makefiles allow Cocotb to only rebuild changed files and their respective parents before it invokes simulation execution.","title":"Format"},{"location":"ECE/markdown/markdown/","text":"What? \u00b6 You can write your assignments in Markdown and render them into PDF. That's how this website was built. How? \u00b6 The Python MkDocs builder consumed the markdown and emitted HTML. You'll also notice that each page has a PDF link. This was accomplished by a post-build run the used pandoc to run over the markdown again and generate PDFs using LaTeX. Why? \u00b6 You should get used to writing in Markdown+LaTeX as the LaTeX typesetting engine has first class performance. In addition, Markdown is widely used in generating documentation for many modern open source projects. LaTeX is also de-facto in academia and is excellent for generating technical and or mathematical documents. Getting Started \u00b6 First you will need to install the full LaTex distribution. Modify for you Linux distro if not Ubuntu. Platform Link MacOS https://tug.org/mactex/mactex-download.html Linux(Ubuntu) or WSL sudo apt install texlive-full Next you need to install pandoc. Make sure you have brew installed. brew install pandoc Finding a Suitable Editor \u00b6 Next you want to find a suitable editor to help you edit your markdown. I like VsCode. It has an especially good markdown mode which is accessible with command + shift + v on Mac, or ctrl + shift + v on PC. I like to have preview mode on one side, and the markdown editor mode on the other using VsCode split screen. Creating a PDF \u00b6 Paste the following into a file called: test.md \u00b6 --- author: John Doe date: January 1, 2020 geometry: margin=1in title: Sample Markdown to LaTeX+PDF with Pandoc header-includes: - \\hypersetup{colorlinks=true} --- # 1. I really like computer architecture. I like computer architecture more than: - money - gold - cars - iPhones ## This is a subsection The proper procedure for starting a new computer architecture design involves: 1. Coming up with the high-level design sketch 2. Initsialising your code space with git VCS 3. Designing each module one by one 4. Commiting changes to git often 4. Always writing unit-tests or testbenches for your code # 2. Open source isn't free - its often funded by institutions. This is a table: | Project | Roots | |--------------|----------------------------| | Verilator | DEC. | | BSD Unix | Berkeley | | Clang | Apple, Berkeley University | | Clang | Berkeley | | Chisel | Berkeley | | R | Berkeley | | Berkeley Sockets | Berkeley | | GCC | MIT | | Xorg | MIT | | Bluespec | MIT | | MIPS | Stanford | | ROS | Stanford | | Theano | University of Montreal | | Firefox | Netscape, Google | | TypeScript | Microsoft | | Linux Kernel | RedHat, IBM, Google | | Chromium | Google | | Android | Google | # This is a third section ## Python Python is a great language for rapid prototyping and unit-testing. Although Python is itself slow, it is often coupled with speedy C/C++ backends allowing for the best of both worlds. One example of such is Python numpy. ### Sub-subsection Some python code ```python def sum(a,b) return a+b ``` Now run the command: pandoc -s test.md -o test.pdf Now open test.pdf . Notice how the Python syntax is highlighted for you.","title":"Markdown to LaTeX+PDF with Pandoc"},{"location":"ECE/markdown/markdown/#what","text":"You can write your assignments in Markdown and render them into PDF. That's how this website was built.","title":"What?"},{"location":"ECE/markdown/markdown/#how","text":"The Python MkDocs builder consumed the markdown and emitted HTML. You'll also notice that each page has a PDF link. This was accomplished by a post-build run the used pandoc to run over the markdown again and generate PDFs using LaTeX.","title":"How?"},{"location":"ECE/markdown/markdown/#why","text":"You should get used to writing in Markdown+LaTeX as the LaTeX typesetting engine has first class performance. In addition, Markdown is widely used in generating documentation for many modern open source projects. LaTeX is also de-facto in academia and is excellent for generating technical and or mathematical documents.","title":"Why?"},{"location":"ECE/markdown/markdown/#getting-started","text":"First you will need to install the full LaTex distribution. Modify for you Linux distro if not Ubuntu. Platform Link MacOS https://tug.org/mactex/mactex-download.html Linux(Ubuntu) or WSL sudo apt install texlive-full Next you need to install pandoc. Make sure you have brew installed. brew install pandoc","title":"Getting Started"},{"location":"ECE/markdown/markdown/#finding-a-suitable-editor","text":"Next you want to find a suitable editor to help you edit your markdown. I like VsCode. It has an especially good markdown mode which is accessible with command + shift + v on Mac, or ctrl + shift + v on PC. I like to have preview mode on one side, and the markdown editor mode on the other using VsCode split screen.","title":"Finding a Suitable Editor"},{"location":"ECE/markdown/markdown/#creating-a-pdf","text":"Paste the following into a file called:","title":"Creating a PDF"},{"location":"ECE/markdown/markdown/#testmd","text":"--- author: John Doe date: January 1, 2020 geometry: margin=1in title: Sample Markdown to LaTeX+PDF with Pandoc header-includes: - \\hypersetup{colorlinks=true} --- # 1. I really like computer architecture. I like computer architecture more than: - money - gold - cars - iPhones ## This is a subsection The proper procedure for starting a new computer architecture design involves: 1. Coming up with the high-level design sketch 2. Initsialising your code space with git VCS 3. Designing each module one by one 4. Commiting changes to git often 4. Always writing unit-tests or testbenches for your code # 2. Open source isn't free - its often funded by institutions. This is a table: | Project | Roots | |--------------|----------------------------| | Verilator | DEC. | | BSD Unix | Berkeley | | Clang | Apple, Berkeley University | | Clang | Berkeley | | Chisel | Berkeley | | R | Berkeley | | Berkeley Sockets | Berkeley | | GCC | MIT | | Xorg | MIT | | Bluespec | MIT | | MIPS | Stanford | | ROS | Stanford | | Theano | University of Montreal | | Firefox | Netscape, Google | | TypeScript | Microsoft | | Linux Kernel | RedHat, IBM, Google | | Chromium | Google | | Android | Google | # This is a third section ## Python Python is a great language for rapid prototyping and unit-testing. Although Python is itself slow, it is often coupled with speedy C/C++ backends allowing for the best of both worlds. One example of such is Python numpy. ### Sub-subsection Some python code ```python def sum(a,b) return a+b ``` Now run the command: pandoc -s test.md -o test.pdf Now open test.pdf . Notice how the Python syntax is highlighted for you.","title":"test.md"},{"location":"ECE/nmigen/nmigen/","text":"What is it? \u00b6 nMigen is a Python based, high level RTL. It uses Yosys to help it emit Verilog. nMigen can perform RTL simulations inside Python. In the near future, nMigen will also be able to use the C++ based YosysCXX as a backend for simulation, resulting in very fast simulations. Installation \u00b6 Install homebrew \u00b6 First, make sure that you have brew installed. Then tap the RTL tools brew tap. On linux , you might have to do the following first. brew tap linuxbrew/xorg Then do: brew tap bracketmaster/rtl Install yosys \u00b6 brew install bracketmaster/rtl/yosys --HEAD Install nMigen \u00b6 It is recommended that you use a virtual python environment. You can use the one you created earlier when installing cocotb . source ~/.virtualenvs/rtl/bin/activate pip3 install git+https://github.com/m-labs/nmigen.git Using nMigen \u00b6 Anytime you want to run Python nMigen code, simply do: source ~/.virtualenvs/rtl/bin/activate and you're off!","title":"Installing nMigen"},{"location":"ECE/nmigen/nmigen/#what-is-it","text":"nMigen is a Python based, high level RTL. It uses Yosys to help it emit Verilog. nMigen can perform RTL simulations inside Python. In the near future, nMigen will also be able to use the C++ based YosysCXX as a backend for simulation, resulting in very fast simulations.","title":"What is it?"},{"location":"ECE/nmigen/nmigen/#installation","text":"","title":"Installation"},{"location":"ECE/nmigen/nmigen/#install-homebrew","text":"First, make sure that you have brew installed. Then tap the RTL tools brew tap. On linux , you might have to do the following first. brew tap linuxbrew/xorg Then do: brew tap bracketmaster/rtl","title":"Install homebrew"},{"location":"ECE/nmigen/nmigen/#install-yosys","text":"brew install bracketmaster/rtl/yosys --HEAD","title":"Install yosys"},{"location":"ECE/nmigen/nmigen/#install-nmigen","text":"It is recommended that you use a virtual python environment. You can use the one you created earlier when installing cocotb . source ~/.virtualenvs/rtl/bin/activate pip3 install git+https://github.com/m-labs/nmigen.git","title":"Install nMigen"},{"location":"ECE/nmigen/nmigen/#using-nmigen","text":"Anytime you want to run Python nMigen code, simply do: source ~/.virtualenvs/rtl/bin/activate and you're off!","title":"Using nMigen"}]}